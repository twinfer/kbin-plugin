// Code generated by kaitai-test-gen-simple.go; DO NOT EDIT.
package formats_test

import (
	"bytes"
	"context"
	"log/slog"
	"maps"
	"os"
	"path/filepath"
	"reflect"
	"strings"
	"testing"

	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kaitai-io/kaitai_struct_go_runtime/kaitai"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/twinfer/kbin-plugin/pkg/kaitaistruct"
	fixed_struct_kaitai "github.com/twinfer/kbin-plugin/testdata/formats_kaitai_go_gen/fixed_struct"
)

func TestParse_FixedStruct(t *testing.T) {
	// Load schema
	ksyPath := filepath.Join("../../../test/formats", "fixed_struct.ksy")
	yamlData, err := os.ReadFile(ksyPath)
	require.NoError(t, err)

	schema, err := kaitaistruct.NewKaitaiSchemaFromYAML(yamlData)
	require.NoError(t, err)
	logger := slog.New(slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{Level: slog.LevelDebug}))
	interpreter, err := kaitaistruct.NewKaitaiInterpreter(schema, logger)
	require.NoError(t, err)

	// Read binary file
	binPath := filepath.Join("../../../test/src", "fixed_struct.bin")
	binData, err := os.ReadFile(binPath)
	require.NoError(t, err)

	// Parse with custom parser
	stream := kaitai.NewStream(bytes.NewReader(binData))
	parsed, err := interpreter.Parse(context.Background(), stream)
	require.NoError(t, err)

	// Convert to map for assertions
	customMap := kaitaistruct.ParsedDataToMap(parsed).(map[string]any)

	// Assertions from KSC test

	// Assert Tmp1.Uint8
	if tmp1_uint8_lvl0_map, ok := customMap["Tmp1"].(map[string]any); ok {
		if tmp1_uint8_val, ok := tmp1_uint8_lvl0_map["Uint8"]; ok {
			assert.EqualValues(t, 255, tmp1_uint8_val)
		} else {
			t.Fatalf("Field 'Uint8' not found in tmp1_uint8_lvl0_map (keys: %v)", maps.Keys(tmp1_uint8_lvl0_map))
		}
	} else {
		t.Fatalf("Field 'Tmp1' not found or not a map while asserting Tmp1.Uint8")
	}

	// Assert Tmp2.Uint16
	if tmp2_uint16_lvl0_map, ok := customMap["Tmp2"].(map[string]any); ok {
		if tmp2_uint16_val, ok := tmp2_uint16_lvl0_map["Uint16"]; ok {
			assert.EqualValues(t, 65535, tmp2_uint16_val)
		} else {
			t.Fatalf("Field 'Uint16' not found in tmp2_uint16_lvl0_map (keys: %v)", maps.Keys(tmp2_uint16_lvl0_map))
		}
	} else {
		t.Fatalf("Field 'Tmp2' not found or not a map while asserting Tmp2.Uint16")
	}

	// Assert Tmp3.Uint32
	if tmp3_uint32_lvl0_map, ok := customMap["Tmp3"].(map[string]any); ok {
		if tmp3_uint32_val, ok := tmp3_uint32_lvl0_map["Uint32"]; ok {
			assert.EqualValues(t, uint32(4294967295), tmp3_uint32_val)
		} else {
			t.Fatalf("Field 'Uint32' not found in tmp3_uint32_lvl0_map (keys: %v)", maps.Keys(tmp3_uint32_lvl0_map))
		}
	} else {
		t.Fatalf("Field 'Tmp3' not found or not a map while asserting Tmp3.Uint32")
	}

	// Assert Tmp4.Uint64
	if tmp4_uint64_lvl0_map, ok := customMap["Tmp4"].(map[string]any); ok {
		if tmp4_uint64_val, ok := tmp4_uint64_lvl0_map["Uint64"]; ok {
			assert.EqualValues(t, uint64(18446744073709551615), tmp4_uint64_val)
		} else {
			t.Fatalf("Field 'Uint64' not found in tmp4_uint64_lvl0_map (keys: %v)", maps.Keys(tmp4_uint64_lvl0_map))
		}
	} else {
		t.Fatalf("Field 'Tmp4' not found or not a map while asserting Tmp4.Uint64")
	}

	// Assert Tmp5.Sint8
	if tmp5_sint8_lvl0_map, ok := customMap["Tmp5"].(map[string]any); ok {
		if tmp5_sint8_val, ok := tmp5_sint8_lvl0_map["Sint8"]; ok {
			assert.EqualValues(t, -1, tmp5_sint8_val)
		} else {
			t.Fatalf("Field 'Sint8' not found in tmp5_sint8_lvl0_map (keys: %v)", maps.Keys(tmp5_sint8_lvl0_map))
		}
	} else {
		t.Fatalf("Field 'Tmp5' not found or not a map while asserting Tmp5.Sint8")
	}

	// Assert Tmp6.Sint16
	if tmp6_sint16_lvl0_map, ok := customMap["Tmp6"].(map[string]any); ok {
		if tmp6_sint16_val, ok := tmp6_sint16_lvl0_map["Sint16"]; ok {
			assert.EqualValues(t, -1, tmp6_sint16_val)
		} else {
			t.Fatalf("Field 'Sint16' not found in tmp6_sint16_lvl0_map (keys: %v)", maps.Keys(tmp6_sint16_lvl0_map))
		}
	} else {
		t.Fatalf("Field 'Tmp6' not found or not a map while asserting Tmp6.Sint16")
	}

	// Assert Tmp7.Sint32
	if tmp7_sint32_lvl0_map, ok := customMap["Tmp7"].(map[string]any); ok {
		if tmp7_sint32_val, ok := tmp7_sint32_lvl0_map["Sint32"]; ok {
			assert.EqualValues(t, -1, tmp7_sint32_val)
		} else {
			t.Fatalf("Field 'Sint32' not found in tmp7_sint32_lvl0_map (keys: %v)", maps.Keys(tmp7_sint32_lvl0_map))
		}
	} else {
		t.Fatalf("Field 'Tmp7' not found or not a map while asserting Tmp7.Sint32")
	}

	// Assert Tmp8.Sint64
	if tmp8_sint64_lvl0_map, ok := customMap["Tmp8"].(map[string]any); ok {
		if tmp8_sint64_val, ok := tmp8_sint64_lvl0_map["Sint64"]; ok {
			assert.EqualValues(t, -1, tmp8_sint64_val)
		} else {
			t.Fatalf("Field 'Sint64' not found in tmp8_sint64_lvl0_map (keys: %v)", maps.Keys(tmp8_sint64_lvl0_map))
		}
	} else {
		t.Fatalf("Field 'Tmp8' not found or not a map while asserting Tmp8.Sint64")
	}

	// Assert Tmp9.Uint16le
	if tmp9_uint16le_lvl0_map, ok := customMap["Tmp9"].(map[string]any); ok {
		if tmp9_uint16le_val, ok := tmp9_uint16le_lvl0_map["Uint16le"]; ok {
			assert.EqualValues(t, 66, tmp9_uint16le_val)
		} else {
			t.Fatalf("Field 'Uint16le' not found in tmp9_uint16le_lvl0_map (keys: %v)", maps.Keys(tmp9_uint16le_lvl0_map))
		}
	} else {
		t.Fatalf("Field 'Tmp9' not found or not a map while asserting Tmp9.Uint16le")
	}

	// Assert Tmp10.Uint32le
	if tmp10_uint32le_lvl0_map, ok := customMap["Tmp10"].(map[string]any); ok {
		if tmp10_uint32le_val, ok := tmp10_uint32le_lvl0_map["Uint32le"]; ok {
			assert.EqualValues(t, 66, tmp10_uint32le_val)
		} else {
			t.Fatalf("Field 'Uint32le' not found in tmp10_uint32le_lvl0_map (keys: %v)", maps.Keys(tmp10_uint32le_lvl0_map))
		}
	} else {
		t.Fatalf("Field 'Tmp10' not found or not a map while asserting Tmp10.Uint32le")
	}

	// Assert Tmp11.Uint64le
	if tmp11_uint64le_lvl0_map, ok := customMap["Tmp11"].(map[string]any); ok {
		if tmp11_uint64le_val, ok := tmp11_uint64le_lvl0_map["Uint64le"]; ok {
			assert.EqualValues(t, 66, tmp11_uint64le_val)
		} else {
			t.Fatalf("Field 'Uint64le' not found in tmp11_uint64le_lvl0_map (keys: %v)", maps.Keys(tmp11_uint64le_lvl0_map))
		}
	} else {
		t.Fatalf("Field 'Tmp11' not found or not a map while asserting Tmp11.Uint64le")
	}

	// Assert Tmp12.Sint16le
	if tmp12_sint16le_lvl0_map, ok := customMap["Tmp12"].(map[string]any); ok {
		if tmp12_sint16le_val, ok := tmp12_sint16le_lvl0_map["Sint16le"]; ok {
			assert.EqualValues(t, -66, tmp12_sint16le_val)
		} else {
			t.Fatalf("Field 'Sint16le' not found in tmp12_sint16le_lvl0_map (keys: %v)", maps.Keys(tmp12_sint16le_lvl0_map))
		}
	} else {
		t.Fatalf("Field 'Tmp12' not found or not a map while asserting Tmp12.Sint16le")
	}

	// Assert Tmp13.Sint32le
	if tmp13_sint32le_lvl0_map, ok := customMap["Tmp13"].(map[string]any); ok {
		if tmp13_sint32le_val, ok := tmp13_sint32le_lvl0_map["Sint32le"]; ok {
			assert.EqualValues(t, -66, tmp13_sint32le_val)
		} else {
			t.Fatalf("Field 'Sint32le' not found in tmp13_sint32le_lvl0_map (keys: %v)", maps.Keys(tmp13_sint32le_lvl0_map))
		}
	} else {
		t.Fatalf("Field 'Tmp13' not found or not a map while asserting Tmp13.Sint32le")
	}

	// Assert Tmp14.Sint64le
	if tmp14_sint64le_lvl0_map, ok := customMap["Tmp14"].(map[string]any); ok {
		if tmp14_sint64le_val, ok := tmp14_sint64le_lvl0_map["Sint64le"]; ok {
			assert.EqualValues(t, -66, tmp14_sint64le_val)
		} else {
			t.Fatalf("Field 'Sint64le' not found in tmp14_sint64le_lvl0_map (keys: %v)", maps.Keys(tmp14_sint64le_lvl0_map))
		}
	} else {
		t.Fatalf("Field 'Tmp14' not found or not a map while asserting Tmp14.Sint64le")
	}

	// Assert Tmp15.Uint16be
	if tmp15_uint16be_lvl0_map, ok := customMap["Tmp15"].(map[string]any); ok {
		if tmp15_uint16be_val, ok := tmp15_uint16be_lvl0_map["Uint16be"]; ok {
			assert.EqualValues(t, 66, tmp15_uint16be_val)
		} else {
			t.Fatalf("Field 'Uint16be' not found in tmp15_uint16be_lvl0_map (keys: %v)", maps.Keys(tmp15_uint16be_lvl0_map))
		}
	} else {
		t.Fatalf("Field 'Tmp15' not found or not a map while asserting Tmp15.Uint16be")
	}

	// Assert Tmp16.Uint32be
	if tmp16_uint32be_lvl0_map, ok := customMap["Tmp16"].(map[string]any); ok {
		if tmp16_uint32be_val, ok := tmp16_uint32be_lvl0_map["Uint32be"]; ok {
			assert.EqualValues(t, 66, tmp16_uint32be_val)
		} else {
			t.Fatalf("Field 'Uint32be' not found in tmp16_uint32be_lvl0_map (keys: %v)", maps.Keys(tmp16_uint32be_lvl0_map))
		}
	} else {
		t.Fatalf("Field 'Tmp16' not found or not a map while asserting Tmp16.Uint32be")
	}

	// Assert Tmp17.Uint64be
	if tmp17_uint64be_lvl0_map, ok := customMap["Tmp17"].(map[string]any); ok {
		if tmp17_uint64be_val, ok := tmp17_uint64be_lvl0_map["Uint64be"]; ok {
			assert.EqualValues(t, 66, tmp17_uint64be_val)
		} else {
			t.Fatalf("Field 'Uint64be' not found in tmp17_uint64be_lvl0_map (keys: %v)", maps.Keys(tmp17_uint64be_lvl0_map))
		}
	} else {
		t.Fatalf("Field 'Tmp17' not found or not a map while asserting Tmp17.Uint64be")
	}

	// Assert Tmp18.Sint16be
	if tmp18_sint16be_lvl0_map, ok := customMap["Tmp18"].(map[string]any); ok {
		if tmp18_sint16be_val, ok := tmp18_sint16be_lvl0_map["Sint16be"]; ok {
			assert.EqualValues(t, -66, tmp18_sint16be_val)
		} else {
			t.Fatalf("Field 'Sint16be' not found in tmp18_sint16be_lvl0_map (keys: %v)", maps.Keys(tmp18_sint16be_lvl0_map))
		}
	} else {
		t.Fatalf("Field 'Tmp18' not found or not a map while asserting Tmp18.Sint16be")
	}

	// Assert Tmp19.Sint32be
	if tmp19_sint32be_lvl0_map, ok := customMap["Tmp19"].(map[string]any); ok {
		if tmp19_sint32be_val, ok := tmp19_sint32be_lvl0_map["Sint32be"]; ok {
			assert.EqualValues(t, -66, tmp19_sint32be_val)
		} else {
			t.Fatalf("Field 'Sint32be' not found in tmp19_sint32be_lvl0_map (keys: %v)", maps.Keys(tmp19_sint32be_lvl0_map))
		}
	} else {
		t.Fatalf("Field 'Tmp19' not found or not a map while asserting Tmp19.Sint32be")
	}

	// Assert Tmp20.Sint64be
	if tmp20_sint64be_lvl0_map, ok := customMap["Tmp20"].(map[string]any); ok {
		if tmp20_sint64be_val, ok := tmp20_sint64be_lvl0_map["Sint64be"]; ok {
			assert.EqualValues(t, -66, tmp20_sint64be_val)
		} else {
			t.Fatalf("Field 'Sint64be' not found in tmp20_sint64be_lvl0_map (keys: %v)", maps.Keys(tmp20_sint64be_lvl0_map))
		}
	} else {
		t.Fatalf("Field 'Tmp20' not found or not a map while asserting Tmp20.Sint64be")
	}

}

func TestSerialize_FixedStruct(t *testing.T) {
	// Load schema
	ksyPath := filepath.Join("../../../test/formats", "fixed_struct.ksy")
	yamlData, err := os.ReadFile(ksyPath)
	require.NoError(t, err)

	schema, err := kaitaistruct.NewKaitaiSchemaFromYAML(yamlData)
	require.NoError(t, err)

	serializer, err := kaitaistruct.NewKaitaiSerializer(schema, nil)
	require.NoError(t, err)

	// Read original binary
	binPath := filepath.Join("../../../test/src", "fixed_struct.bin")
	originalData, err := os.ReadFile(binPath)
	require.NoError(t, err)

	// Parse original
	stream := kaitai.NewStream(bytes.NewReader(originalData))
	original := fixed_struct_kaitai.NewFixedStruct()
	err = original.Read(stream, original, original)
	require.NoError(t, err)

	// Serialize and verify round-trip
	inputMap := structToMapFixedStruct(t, original)

	serialized, err := serializer.Serialize(context.Background(), inputMap)
	require.NoError(t, err)

	// Parse serialized data
	stream2 := kaitai.NewStream(bytes.NewReader(serialized))
	reparsed := fixed_struct_kaitai.NewFixedStruct()
	err = reparsed.Read(stream2, reparsed, reparsed)
	require.NoError(t, err)

	// Compare structures with Phase 2/3 enhanced comparison
	cmpOpts := []cmp.Option{
		cmpopts.IgnoreUnexported(
			kaitai.Stream{},
		),
		cmpopts.IgnoreFields(fixed_struct_kaitai.FixedStruct{}, "_io", "_parent", "_root"),
		cmpopts.EquateEmpty(),
	}
	if diff := cmp.Diff(original, reparsed, cmpOpts...); diff != "" {
		t.Errorf("Serialization mismatch (-original +reparsed):\n%s", diff)
	}
}

// structToMapFixedStruct converts KSC struct to map for serializer
func structToMapFixedStruct(t *testing.T, data any) map[string]any {
	// Use reflection to handle KSC structs with method-based values
	return structToMapReflectiveFixedStruct(t, data)
}

// structToMapReflectiveFixedStruct uses reflection to convert KSC structs including method calls
func structToMapReflectiveFixedStruct(t *testing.T, data any) map[string]any {
	result := make(map[string]any)

	val := reflect.ValueOf(data)
	if val.Kind() == reflect.Ptr {
		val = val.Elem()
	}

	typ := val.Type()

	// Process fields
	for i := 0; i < val.NumField(); i++ {
		field := typ.Field(i)
		fieldVal := val.Field(i)

		// Skip internal KSC fields
		if strings.HasPrefix(field.Name, "_") {
			continue
		}

		fieldName := strings.ToLower(field.Name)

		if !fieldVal.IsValid() || fieldVal.IsZero() {
			continue
		}

		// Handle different field types
		switch fieldVal.Kind() {
		case reflect.Ptr:
			if !fieldVal.IsNil() {
				// For custom types, check for AsInt/AsStr methods
				subResult := make(map[string]any)

				// Try to call AsInt method
				if method := fieldVal.MethodByName("AsInt"); method.IsValid() {
					if results := method.Call(nil); len(results) == 2 && results[1].IsNil() {
						subResult["asint"] = results[0].Interface()
					}
				}

				// Try to call AsStr method
				if method := fieldVal.MethodByName("AsStr"); method.IsValid() {
					if results := method.Call(nil); len(results) == 2 && results[1].IsNil() {
						subResult["asstr"] = results[0].Interface()
					}
				}

				// Also include raw fields
				subMap := structToMapReflectiveFixedStruct(t, fieldVal.Interface())
				for k, v := range subMap {
					if _, exists := subResult[k]; !exists {
						subResult[k] = v
					}
				}

				result[fieldName] = subResult
			}
		case reflect.Slice:
			if fieldVal.Len() > 0 {
				slice := make([]any, fieldVal.Len())
				for j := 0; j < fieldVal.Len(); j++ {
					slice[j] = fieldVal.Index(j).Interface()
				}
				result[fieldName] = slice
			}
		default:
			result[fieldName] = fieldVal.Interface()
		}
	}

	return result
}
