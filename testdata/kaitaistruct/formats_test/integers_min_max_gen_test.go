// Code generated by kaitai-test-gen-simple.go; DO NOT EDIT.
package formats_test

import (
	"bytes"
	"context"
	"log/slog"
	"maps"
	"os"
	"path/filepath"
	"reflect"
	"strings"
	"testing"

	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kaitai-io/kaitai_struct_go_runtime/kaitai"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/twinfer/kbin-plugin/pkg/kaitaistruct"
	integers_min_max_kaitai "github.com/twinfer/kbin-plugin/testdata/formats_kaitai_go_gen/integers_min_max"
)

func TestParse_IntegersMinMax(t *testing.T) {
	// Load schema
	ksyPath := filepath.Join("../../../test/formats", "integers_min_max.ksy")
	yamlData, err := os.ReadFile(ksyPath)
	require.NoError(t, err)

	schema, err := kaitaistruct.NewKaitaiSchemaFromYAML(yamlData)
	require.NoError(t, err)
	logger := slog.New(slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{Level: slog.LevelDebug}))
	interpreter, err := kaitaistruct.NewKaitaiInterpreter(schema, logger)
	require.NoError(t, err)

	// Read binary file
	binPath := filepath.Join("../../../test/src", "integers_min_max.bin")
	binData, err := os.ReadFile(binPath)
	require.NoError(t, err)

	// Parse with custom parser
	stream := kaitai.NewStream(bytes.NewReader(binData))
	parsed, err := interpreter.Parse(context.Background(), stream)
	require.NoError(t, err)

	// Convert to map for assertions
	customMap := kaitaistruct.ParsedDataToMap(parsed).(map[string]any)

	// Assertions from KSC test

	// Assert UnsignedMin.U1
	if unsignedmin_u1_lvl0_map, ok := customMap["UnsignedMin"].(map[string]any); ok {
		if unsignedmin_u1_val, ok := unsignedmin_u1_lvl0_map["U1"]; ok {
			assert.EqualValues(t, 0, unsignedmin_u1_val)
		} else {
			t.Fatalf("Field 'U1' not found in unsignedmin_u1_lvl0_map (keys: %v)", maps.Keys(unsignedmin_u1_lvl0_map))
		}
	} else {
		t.Fatalf("Field 'UnsignedMin' not found or not a map while asserting UnsignedMin.U1")
	}

	// Assert UnsignedMin.U2le
	if unsignedmin_u2le_lvl0_map, ok := customMap["UnsignedMin"].(map[string]any); ok {
		if unsignedmin_u2le_val, ok := unsignedmin_u2le_lvl0_map["U2le"]; ok {
			assert.EqualValues(t, 0, unsignedmin_u2le_val)
		} else {
			t.Fatalf("Field 'U2le' not found in unsignedmin_u2le_lvl0_map (keys: %v)", maps.Keys(unsignedmin_u2le_lvl0_map))
		}
	} else {
		t.Fatalf("Field 'UnsignedMin' not found or not a map while asserting UnsignedMin.U2le")
	}

	// Assert UnsignedMin.U4le
	if unsignedmin_u4le_lvl0_map, ok := customMap["UnsignedMin"].(map[string]any); ok {
		if unsignedmin_u4le_val, ok := unsignedmin_u4le_lvl0_map["U4le"]; ok {
			assert.EqualValues(t, 0, unsignedmin_u4le_val)
		} else {
			t.Fatalf("Field 'U4le' not found in unsignedmin_u4le_lvl0_map (keys: %v)", maps.Keys(unsignedmin_u4le_lvl0_map))
		}
	} else {
		t.Fatalf("Field 'UnsignedMin' not found or not a map while asserting UnsignedMin.U4le")
	}

	// Assert UnsignedMin.U8le
	if unsignedmin_u8le_lvl0_map, ok := customMap["UnsignedMin"].(map[string]any); ok {
		if unsignedmin_u8le_val, ok := unsignedmin_u8le_lvl0_map["U8le"]; ok {
			assert.EqualValues(t, 0, unsignedmin_u8le_val)
		} else {
			t.Fatalf("Field 'U8le' not found in unsignedmin_u8le_lvl0_map (keys: %v)", maps.Keys(unsignedmin_u8le_lvl0_map))
		}
	} else {
		t.Fatalf("Field 'UnsignedMin' not found or not a map while asserting UnsignedMin.U8le")
	}

	// Assert UnsignedMin.U2be
	if unsignedmin_u2be_lvl0_map, ok := customMap["UnsignedMin"].(map[string]any); ok {
		if unsignedmin_u2be_val, ok := unsignedmin_u2be_lvl0_map["U2be"]; ok {
			assert.EqualValues(t, 0, unsignedmin_u2be_val)
		} else {
			t.Fatalf("Field 'U2be' not found in unsignedmin_u2be_lvl0_map (keys: %v)", maps.Keys(unsignedmin_u2be_lvl0_map))
		}
	} else {
		t.Fatalf("Field 'UnsignedMin' not found or not a map while asserting UnsignedMin.U2be")
	}

	// Assert UnsignedMin.U4be
	if unsignedmin_u4be_lvl0_map, ok := customMap["UnsignedMin"].(map[string]any); ok {
		if unsignedmin_u4be_val, ok := unsignedmin_u4be_lvl0_map["U4be"]; ok {
			assert.EqualValues(t, 0, unsignedmin_u4be_val)
		} else {
			t.Fatalf("Field 'U4be' not found in unsignedmin_u4be_lvl0_map (keys: %v)", maps.Keys(unsignedmin_u4be_lvl0_map))
		}
	} else {
		t.Fatalf("Field 'UnsignedMin' not found or not a map while asserting UnsignedMin.U4be")
	}

	// Assert UnsignedMin.U8be
	if unsignedmin_u8be_lvl0_map, ok := customMap["UnsignedMin"].(map[string]any); ok {
		if unsignedmin_u8be_val, ok := unsignedmin_u8be_lvl0_map["U8be"]; ok {
			assert.EqualValues(t, 0, unsignedmin_u8be_val)
		} else {
			t.Fatalf("Field 'U8be' not found in unsignedmin_u8be_lvl0_map (keys: %v)", maps.Keys(unsignedmin_u8be_lvl0_map))
		}
	} else {
		t.Fatalf("Field 'UnsignedMin' not found or not a map while asserting UnsignedMin.U8be")
	}

	// Assert UnsignedMax.U1
	if unsignedmax_u1_lvl0_map, ok := customMap["UnsignedMax"].(map[string]any); ok {
		if unsignedmax_u1_val, ok := unsignedmax_u1_lvl0_map["U1"]; ok {
			assert.EqualValues(t, 255, unsignedmax_u1_val)
		} else {
			t.Fatalf("Field 'U1' not found in unsignedmax_u1_lvl0_map (keys: %v)", maps.Keys(unsignedmax_u1_lvl0_map))
		}
	} else {
		t.Fatalf("Field 'UnsignedMax' not found or not a map while asserting UnsignedMax.U1")
	}

	// Assert UnsignedMax.U2le
	if unsignedmax_u2le_lvl0_map, ok := customMap["UnsignedMax"].(map[string]any); ok {
		if unsignedmax_u2le_val, ok := unsignedmax_u2le_lvl0_map["U2le"]; ok {
			assert.EqualValues(t, 65535, unsignedmax_u2le_val)
		} else {
			t.Fatalf("Field 'U2le' not found in unsignedmax_u2le_lvl0_map (keys: %v)", maps.Keys(unsignedmax_u2le_lvl0_map))
		}
	} else {
		t.Fatalf("Field 'UnsignedMax' not found or not a map while asserting UnsignedMax.U2le")
	}

	// Assert UnsignedMax.U4le
	if unsignedmax_u4le_lvl0_map, ok := customMap["UnsignedMax"].(map[string]any); ok {
		if unsignedmax_u4le_val, ok := unsignedmax_u4le_lvl0_map["U4le"]; ok {
			assert.EqualValues(t, uint32(4294967295), unsignedmax_u4le_val)
		} else {
			t.Fatalf("Field 'U4le' not found in unsignedmax_u4le_lvl0_map (keys: %v)", maps.Keys(unsignedmax_u4le_lvl0_map))
		}
	} else {
		t.Fatalf("Field 'UnsignedMax' not found or not a map while asserting UnsignedMax.U4le")
	}

	// Assert UnsignedMax.U8le
	if unsignedmax_u8le_lvl0_map, ok := customMap["UnsignedMax"].(map[string]any); ok {
		if unsignedmax_u8le_val, ok := unsignedmax_u8le_lvl0_map["U8le"]; ok {
			assert.EqualValues(t, uint64(18446744073709551615), unsignedmax_u8le_val)
		} else {
			t.Fatalf("Field 'U8le' not found in unsignedmax_u8le_lvl0_map (keys: %v)", maps.Keys(unsignedmax_u8le_lvl0_map))
		}
	} else {
		t.Fatalf("Field 'UnsignedMax' not found or not a map while asserting UnsignedMax.U8le")
	}

	// Assert UnsignedMax.U2be
	if unsignedmax_u2be_lvl0_map, ok := customMap["UnsignedMax"].(map[string]any); ok {
		if unsignedmax_u2be_val, ok := unsignedmax_u2be_lvl0_map["U2be"]; ok {
			assert.EqualValues(t, 65535, unsignedmax_u2be_val)
		} else {
			t.Fatalf("Field 'U2be' not found in unsignedmax_u2be_lvl0_map (keys: %v)", maps.Keys(unsignedmax_u2be_lvl0_map))
		}
	} else {
		t.Fatalf("Field 'UnsignedMax' not found or not a map while asserting UnsignedMax.U2be")
	}

	// Assert UnsignedMax.U4be
	if unsignedmax_u4be_lvl0_map, ok := customMap["UnsignedMax"].(map[string]any); ok {
		if unsignedmax_u4be_val, ok := unsignedmax_u4be_lvl0_map["U4be"]; ok {
			assert.EqualValues(t, uint32(4294967295), unsignedmax_u4be_val)
		} else {
			t.Fatalf("Field 'U4be' not found in unsignedmax_u4be_lvl0_map (keys: %v)", maps.Keys(unsignedmax_u4be_lvl0_map))
		}
	} else {
		t.Fatalf("Field 'UnsignedMax' not found or not a map while asserting UnsignedMax.U4be")
	}

	// Assert UnsignedMax.U8be
	if unsignedmax_u8be_lvl0_map, ok := customMap["UnsignedMax"].(map[string]any); ok {
		if unsignedmax_u8be_val, ok := unsignedmax_u8be_lvl0_map["U8be"]; ok {
			assert.EqualValues(t, uint64(18446744073709551615), unsignedmax_u8be_val)
		} else {
			t.Fatalf("Field 'U8be' not found in unsignedmax_u8be_lvl0_map (keys: %v)", maps.Keys(unsignedmax_u8be_lvl0_map))
		}
	} else {
		t.Fatalf("Field 'UnsignedMax' not found or not a map while asserting UnsignedMax.U8be")
	}

	// Assert SignedMin.S1
	if signedmin_s1_lvl0_map, ok := customMap["SignedMin"].(map[string]any); ok {
		if signedmin_s1_val, ok := signedmin_s1_lvl0_map["S1"]; ok {
			assert.EqualValues(t, -128, signedmin_s1_val)
		} else {
			t.Fatalf("Field 'S1' not found in signedmin_s1_lvl0_map (keys: %v)", maps.Keys(signedmin_s1_lvl0_map))
		}
	} else {
		t.Fatalf("Field 'SignedMin' not found or not a map while asserting SignedMin.S1")
	}

	// Assert SignedMin.S2le
	if signedmin_s2le_lvl0_map, ok := customMap["SignedMin"].(map[string]any); ok {
		if signedmin_s2le_val, ok := signedmin_s2le_lvl0_map["S2le"]; ok {
			assert.EqualValues(t, -32768, signedmin_s2le_val)
		} else {
			t.Fatalf("Field 'S2le' not found in signedmin_s2le_lvl0_map (keys: %v)", maps.Keys(signedmin_s2le_lvl0_map))
		}
	} else {
		t.Fatalf("Field 'SignedMin' not found or not a map while asserting SignedMin.S2le")
	}

	// Assert SignedMin.S4le
	if signedmin_s4le_lvl0_map, ok := customMap["SignedMin"].(map[string]any); ok {
		if signedmin_s4le_val, ok := signedmin_s4le_lvl0_map["S4le"]; ok {
			assert.EqualValues(t, -2147483648, signedmin_s4le_val)
		} else {
			t.Fatalf("Field 'S4le' not found in signedmin_s4le_lvl0_map (keys: %v)", maps.Keys(signedmin_s4le_lvl0_map))
		}
	} else {
		t.Fatalf("Field 'SignedMin' not found or not a map while asserting SignedMin.S4le")
	}

	// Assert SignedMin.S8le
	if signedmin_s8le_lvl0_map, ok := customMap["SignedMin"].(map[string]any); ok {
		if signedmin_s8le_val, ok := signedmin_s8le_lvl0_map["S8le"]; ok {
			assert.EqualValues(t, int64(-9223372036854775808), signedmin_s8le_val)
		} else {
			t.Fatalf("Field 'S8le' not found in signedmin_s8le_lvl0_map (keys: %v)", maps.Keys(signedmin_s8le_lvl0_map))
		}
	} else {
		t.Fatalf("Field 'SignedMin' not found or not a map while asserting SignedMin.S8le")
	}

	// Assert SignedMin.S2be
	if signedmin_s2be_lvl0_map, ok := customMap["SignedMin"].(map[string]any); ok {
		if signedmin_s2be_val, ok := signedmin_s2be_lvl0_map["S2be"]; ok {
			assert.EqualValues(t, -32768, signedmin_s2be_val)
		} else {
			t.Fatalf("Field 'S2be' not found in signedmin_s2be_lvl0_map (keys: %v)", maps.Keys(signedmin_s2be_lvl0_map))
		}
	} else {
		t.Fatalf("Field 'SignedMin' not found or not a map while asserting SignedMin.S2be")
	}

	// Assert SignedMin.S4be
	if signedmin_s4be_lvl0_map, ok := customMap["SignedMin"].(map[string]any); ok {
		if signedmin_s4be_val, ok := signedmin_s4be_lvl0_map["S4be"]; ok {
			assert.EqualValues(t, -2147483648, signedmin_s4be_val)
		} else {
			t.Fatalf("Field 'S4be' not found in signedmin_s4be_lvl0_map (keys: %v)", maps.Keys(signedmin_s4be_lvl0_map))
		}
	} else {
		t.Fatalf("Field 'SignedMin' not found or not a map while asserting SignedMin.S4be")
	}

	// Assert SignedMin.S8be
	if signedmin_s8be_lvl0_map, ok := customMap["SignedMin"].(map[string]any); ok {
		if signedmin_s8be_val, ok := signedmin_s8be_lvl0_map["S8be"]; ok {
			assert.EqualValues(t, int64(-9223372036854775808), signedmin_s8be_val)
		} else {
			t.Fatalf("Field 'S8be' not found in signedmin_s8be_lvl0_map (keys: %v)", maps.Keys(signedmin_s8be_lvl0_map))
		}
	} else {
		t.Fatalf("Field 'SignedMin' not found or not a map while asserting SignedMin.S8be")
	}

	// Assert SignedMax.S1
	if signedmax_s1_lvl0_map, ok := customMap["SignedMax"].(map[string]any); ok {
		if signedmax_s1_val, ok := signedmax_s1_lvl0_map["S1"]; ok {
			assert.EqualValues(t, 127, signedmax_s1_val)
		} else {
			t.Fatalf("Field 'S1' not found in signedmax_s1_lvl0_map (keys: %v)", maps.Keys(signedmax_s1_lvl0_map))
		}
	} else {
		t.Fatalf("Field 'SignedMax' not found or not a map while asserting SignedMax.S1")
	}

	// Assert SignedMax.S2le
	if signedmax_s2le_lvl0_map, ok := customMap["SignedMax"].(map[string]any); ok {
		if signedmax_s2le_val, ok := signedmax_s2le_lvl0_map["S2le"]; ok {
			assert.EqualValues(t, 32767, signedmax_s2le_val)
		} else {
			t.Fatalf("Field 'S2le' not found in signedmax_s2le_lvl0_map (keys: %v)", maps.Keys(signedmax_s2le_lvl0_map))
		}
	} else {
		t.Fatalf("Field 'SignedMax' not found or not a map while asserting SignedMax.S2le")
	}

	// Assert SignedMax.S4le
	if signedmax_s4le_lvl0_map, ok := customMap["SignedMax"].(map[string]any); ok {
		if signedmax_s4le_val, ok := signedmax_s4le_lvl0_map["S4le"]; ok {
			assert.EqualValues(t, 2147483647, signedmax_s4le_val)
		} else {
			t.Fatalf("Field 'S4le' not found in signedmax_s4le_lvl0_map (keys: %v)", maps.Keys(signedmax_s4le_lvl0_map))
		}
	} else {
		t.Fatalf("Field 'SignedMax' not found or not a map while asserting SignedMax.S4le")
	}

	// Assert SignedMax.S8le
	if signedmax_s8le_lvl0_map, ok := customMap["SignedMax"].(map[string]any); ok {
		if signedmax_s8le_val, ok := signedmax_s8le_lvl0_map["S8le"]; ok {
			assert.EqualValues(t, int64(9223372036854775807), signedmax_s8le_val)
		} else {
			t.Fatalf("Field 'S8le' not found in signedmax_s8le_lvl0_map (keys: %v)", maps.Keys(signedmax_s8le_lvl0_map))
		}
	} else {
		t.Fatalf("Field 'SignedMax' not found or not a map while asserting SignedMax.S8le")
	}

	// Assert SignedMax.S2be
	if signedmax_s2be_lvl0_map, ok := customMap["SignedMax"].(map[string]any); ok {
		if signedmax_s2be_val, ok := signedmax_s2be_lvl0_map["S2be"]; ok {
			assert.EqualValues(t, 32767, signedmax_s2be_val)
		} else {
			t.Fatalf("Field 'S2be' not found in signedmax_s2be_lvl0_map (keys: %v)", maps.Keys(signedmax_s2be_lvl0_map))
		}
	} else {
		t.Fatalf("Field 'SignedMax' not found or not a map while asserting SignedMax.S2be")
	}

	// Assert SignedMax.S4be
	if signedmax_s4be_lvl0_map, ok := customMap["SignedMax"].(map[string]any); ok {
		if signedmax_s4be_val, ok := signedmax_s4be_lvl0_map["S4be"]; ok {
			assert.EqualValues(t, 2147483647, signedmax_s4be_val)
		} else {
			t.Fatalf("Field 'S4be' not found in signedmax_s4be_lvl0_map (keys: %v)", maps.Keys(signedmax_s4be_lvl0_map))
		}
	} else {
		t.Fatalf("Field 'SignedMax' not found or not a map while asserting SignedMax.S4be")
	}

	// Assert SignedMax.S8be
	if signedmax_s8be_lvl0_map, ok := customMap["SignedMax"].(map[string]any); ok {
		if signedmax_s8be_val, ok := signedmax_s8be_lvl0_map["S8be"]; ok {
			assert.EqualValues(t, int64(9223372036854775807), signedmax_s8be_val)
		} else {
			t.Fatalf("Field 'S8be' not found in signedmax_s8be_lvl0_map (keys: %v)", maps.Keys(signedmax_s8be_lvl0_map))
		}
	} else {
		t.Fatalf("Field 'SignedMax' not found or not a map while asserting SignedMax.S8be")
	}

}

func TestSerialize_IntegersMinMax(t *testing.T) {
	// Load schema
	ksyPath := filepath.Join("../../../test/formats", "integers_min_max.ksy")
	yamlData, err := os.ReadFile(ksyPath)
	require.NoError(t, err)

	schema, err := kaitaistruct.NewKaitaiSchemaFromYAML(yamlData)
	require.NoError(t, err)

	serializer, err := kaitaistruct.NewKaitaiSerializer(schema, nil)
	require.NoError(t, err)

	// Read original binary
	binPath := filepath.Join("../../../test/src", "integers_min_max.bin")
	originalData, err := os.ReadFile(binPath)
	require.NoError(t, err)

	// Parse original
	stream := kaitai.NewStream(bytes.NewReader(originalData))
	original := integers_min_max_kaitai.NewIntegersMinMax()
	err = original.Read(stream, original, original)
	require.NoError(t, err)

	// Serialize and verify round-trip
	inputMap := structToMapIntegersMinMax(t, original)

	serialized, err := serializer.Serialize(context.Background(), inputMap)
	require.NoError(t, err)

	// Parse serialized data
	stream2 := kaitai.NewStream(bytes.NewReader(serialized))
	reparsed := integers_min_max_kaitai.NewIntegersMinMax()
	err = reparsed.Read(stream2, reparsed, reparsed)
	require.NoError(t, err)

	// Compare structures with Phase 2/3 enhanced comparison
	cmpOpts := []cmp.Option{
		cmpopts.IgnoreUnexported(
			kaitai.Stream{},
		),
		cmpopts.IgnoreFields(integers_min_max_kaitai.IntegersMinMax{}, "_io", "_parent", "_root"),
		cmpopts.EquateEmpty(),
	}
	if diff := cmp.Diff(original, reparsed, cmpOpts...); diff != "" {
		t.Errorf("Serialization mismatch (-original +reparsed):\n%s", diff)
	}
}

// structToMapIntegersMinMax converts KSC struct to map for serializer
func structToMapIntegersMinMax(t *testing.T, data any) map[string]any {
	// Use reflection to handle KSC structs with method-based values
	return structToMapReflectiveIntegersMinMax(t, data)
}

// structToMapReflectiveIntegersMinMax uses reflection to convert KSC structs including method calls
func structToMapReflectiveIntegersMinMax(t *testing.T, data any) map[string]any {
	result := make(map[string]any)

	val := reflect.ValueOf(data)
	if val.Kind() == reflect.Ptr {
		val = val.Elem()
	}

	typ := val.Type()

	// Process fields
	for i := 0; i < val.NumField(); i++ {
		field := typ.Field(i)
		fieldVal := val.Field(i)

		// Skip internal KSC fields
		if strings.HasPrefix(field.Name, "_") {
			continue
		}

		fieldName := strings.ToLower(field.Name)

		if !fieldVal.IsValid() || fieldVal.IsZero() {
			continue
		}

		// Handle different field types
		switch fieldVal.Kind() {
		case reflect.Ptr:
			if !fieldVal.IsNil() {
				// For custom types, check for AsInt/AsStr methods
				subResult := make(map[string]any)

				// Try to call AsInt method
				if method := fieldVal.MethodByName("AsInt"); method.IsValid() {
					if results := method.Call(nil); len(results) == 2 && results[1].IsNil() {
						subResult["asint"] = results[0].Interface()
					}
				}

				// Try to call AsStr method
				if method := fieldVal.MethodByName("AsStr"); method.IsValid() {
					if results := method.Call(nil); len(results) == 2 && results[1].IsNil() {
						subResult["asstr"] = results[0].Interface()
					}
				}

				// Also include raw fields
				subMap := structToMapReflectiveIntegersMinMax(t, fieldVal.Interface())
				for k, v := range subMap {
					if _, exists := subResult[k]; !exists {
						subResult[k] = v
					}
				}

				result[fieldName] = subResult
			}
		case reflect.Slice:
			if fieldVal.Len() > 0 {
				slice := make([]any, fieldVal.Len())
				for j := 0; j < fieldVal.Len(); j++ {
					slice[j] = fieldVal.Index(j).Interface()
				}
				result[fieldName] = slice
			}
		default:
			result[fieldName] = fieldVal.Interface()
		}
	}

	return result
}
