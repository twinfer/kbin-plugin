package main

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"gopkg.in/yaml.v3"
)

// SequenceItem represents a field in the Kaitai schema
type SequenceItem struct {
	ID       string `yaml:"id"`
	Type     string `yaml:"type"`
	Contents any    `yaml:"contents,omitempty"`
	Repeat   string `yaml:"repeat,omitempty"`
}

// TypeDef represents a user-defined type in the Kaitai schema
type TypeDef struct {
	Seq       []SequenceItem          `yaml:"seq"`
	Instances map[string]InstanceItem `yaml:"instances,omitempty"`
}

// InstanceItem represents an instance in the Kaitai schema
type InstanceItem struct {
	Type  string `yaml:"type"`
	Value string `yaml:"value,omitempty"`
}

// KaitaiSchema represents the full Kaitai schema
type KaitaiSchema struct {
	Meta struct {
		ID     string `yaml:"id"`
		Endian string `yaml:"endian,omitempty"`
	} `yaml:"meta"`
	Seq       []SequenceItem          `yaml:"seq"`
	Types     map[string]TypeDef      `yaml:"types,omitempty"`
	Instances map[string]InstanceItem `yaml:"instances,omitempty"`
}

// TestTemplate contains the template for generating the test file
const testTemplate = `
// Code generated by gen_ksy_tests.go. DO NOT EDIT.
//go:build !ignore_autogenerated
// Package {{ .PackageName }} contains tests for the Kaitai schema {{ .SchemaPath }}
package {{ .PackageName }}_test

import (
    "bytes"
    "os"
    "testing"

    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"

    "github.com/twinfer/kbin-plugin/pkg/kaitaistruct"
    "github.com/kaitai-io/kaitai_struct_go_runtime/kaitai"
)

func Test_{{ .TestName }}_Interpreter(t *testing.T) {
    // Load the schema
    schemaBytes, err := os.ReadFile("{{ .SchemaPath }}")
    require.NoError(t, err, "Failed to read schema file")

    schema, err := kaitaistruct.ParseKaitaiSchema(schemaBytes)
    require.NoError(t, err, "Failed to parse schema")

    // Load binary test data
    binData, err := os.ReadFile("{{ .BinaryPath }}")
    require.NoError(t, err, "Failed to read binary test data")

    // Create interpreter and parse the data
    interpreter := kaitaistruct.NewKaitaiInterpreter(schema)
    stream := kaitai.NewStream(bytes.NewReader(binData))
    result, err := interpreter.Parse(stream)
    require.NoError(t, err, "Failed to parse binary data")

    // Convert to map for easier testing
    parsedData := kaitaistruct.ParsedDataToMap(result)
    require.NotNil(t, parsedData, "Parsed data should not be nil")

    {{ if .RootIsMap }}
    // Cast to map for assertions
    dataMap, ok := parsedData.(map[string]interface{})
    require.True(t, ok, "Parsed data should be a map")

    // Test field values
    {{ range .FieldAssertions }}
    {{ . }}
    {{ end }}
    {{ else }}
    // Test value directly
    {{ range .FieldAssertions }}
    {{ . }}
    {{ end }}
    {{ end }}
}

func Test_{{ .TestName }}_Serializer(t *testing.T) {
    // Load the schema
    schemaBytes, err := os.ReadFile("{{ .SchemaPath }}")
    require.NoError(t, err, "Failed to read schema file")

    schema, err := kaitaistruct.ParseKaitaiSchema(schemaBytes)
    require.NoError(t, err, "Failed to parse schema")

    // Load binary test data for reference
    originalBinData, err := os.ReadFile("{{ .BinaryPath }}")
    require.NoError(t, err, "Failed to read binary test data")

    // First parse the data with the interpreter
    interpreter := kaitaistruct.NewKaitaiInterpreter(schema)
    stream := kaitai.NewStream(bytes.NewReader(originalBinData))
    result, err := interpreter.Parse(stream)
    require.NoError(t, err, "Failed to parse binary data")

    // Convert to map for serialization
    parsedDataMap := kaitaistruct.ParsedDataToMap(result)

    // Now serialize the parsed data
    serializer := kaitaistruct.NewKaitaiSerializer(schema)
    var buf bytes.Buffer
    writer := kaitai.NewWriter(&buf)
    err = serializer.SerializeToWriter(parsedDataMap, writer)
    require.NoError(t, err, "Failed to serialize data")
    serializedData := buf.Bytes()

    {{ if .CanCompareDirectly }}
    // For simple cases, the serialized data should match the original
    assert.Equal(t, originalBinData, serializedData, "Serialized data should match original")
    {{ else }}
    // For complex cases, we validate by reparsing the serialized data
    reparsedStream := kaitai.NewStream(bytes.NewReader(serializedData))
    reparsedResult, err := interpreter.Parse(reparsedStream)
    require.NoError(t, err, "Failed to reparse serialized data")

    reparsedDataMap := kaitaistruct.ParsedDataToMap(reparsedResult)

    // Compare the reparsed data with the original parsed data
    assert.Equal(t, parsedDataMap, reparsedDataMap, "Reparsed data should match original parsed data")
    {{ end }}
}

// TestRoundTrip validates that data can be parsed and then serialized back
func Test_{{ .TestName }}_RoundTrip(t *testing.T) {
    // Load the schema
    schemaBytes, err := os.ReadFile("{{ .SchemaPath }}")
    require.NoError(t, err, "Failed to read schema file")

    schema, err := kaitaistruct.ParseKaitaiSchema(schemaBytes)
    require.NoError(t, err, "Failed to parse schema")

    // Load binary test data
    originalBinData, err := os.ReadFile("{{ .BinaryPath }}")
    require.NoError(t, err, "Failed to read binary test data")

    // STEP 1: Parse the original data
    interpreter := kaitaistruct.NewKaitaiInterpreter(schema)
    stream := kaitai.NewStream(bytes.NewReader(originalBinData))
    result, err := interpreter.Parse(stream)
    require.NoError(t, err, "Failed to parse binary data")

    // Convert to map
    parsedDataMap := kaitaistruct.ParsedDataToMap(result)

    // STEP 2: Serialize the parsed data
    serializer := kaitaistruct.NewKaitaiSerializer(schema)
    var buf bytes.Buffer
    writer := kaitai.NewWriter(&buf)
    err = serializer.SerializeToWriter(parsedDataMap, writer)
    require.NoError(t, err, "Failed to serialize data")
    serializedData := buf.Bytes()

    // STEP 3: Reparse the serialized data
    reparsedStream := kaitai.NewStream(bytes.NewReader(serializedData))
    reparsedResult, err := interpreter.Parse(reparsedStream)
    require.NoError(t, err, "Failed to reparse serialized data")

    // Convert to map
    reparsedDataMap := kaitaistruct.ParsedDataToMap(reparsedResult)

    // STEP 4: Compare the original parsed data with the reparsed data
    assert.Equal(t, parsedDataMap, reparsedDataMap, "Round-trip data should match")
}
`

// SimpleTestData represents data for a template generation
type SimpleTestData struct {
	PackageName        string
	TestName           string
	SchemaPath         string
	BinaryPath         string
	RootIsMap          bool
	FieldAssertions    []string
	CanCompareDirectly bool
}

// guessBinaryPath tries to find a matching binary file
func guessBinaryPath(schemaPath string) string {
	dir := filepath.Dir(schemaPath)
	base := filepath.Base(schemaPath)
	baseName := strings.TrimSuffix(base, filepath.Ext(base))

	// 1. Try .bin file in the same directory as the .ksy
	binPath := filepath.Join(dir, baseName+".bin")
	if _, err := os.Stat(binPath); err == nil {
		return baseName + ".bin" // just the filename, for local open
	}

	// 2. Try variations in the same directory
	variations := []string{
		baseName + ".bin",
		strings.ReplaceAll(baseName, "_", ".") + ".bin",
		strings.ReplaceAll(baseName, "-", ".") + ".bin",
	}
	for _, variation := range variations {
		binPath := filepath.Join(dir, variation)
		if _, err := os.Stat(binPath); err == nil {
			return variation
		}
	}

	// 3. Try testdata/testdata/kaitai/ with a relative path
	testdataDir := filepath.Join("testdata", "testdata", "kaitai")
	for _, variation := range append([]string{baseName + ".bin"}, variations...) {
		absBinPath := filepath.Join(testdataDir, variation)
		if _, err := os.Stat(absBinPath); err == nil {
			rel, _ := filepath.Rel(dir, absBinPath)
			return rel
		}
	}

	// 4. Fallback: just use the default name in the same dir
	return baseName + ".bin"
}

// generateFieldAssertions creates assertion statements for fields
func generateFieldAssertions(schema KaitaiSchema) []string {
	assertions := []string{}

	// Process root level sequence
	for _, field := range schema.Seq {
		assertions = append(assertions, generateFieldAssertion(field, "dataMap"))
	}

	// Process instances if any
	for name, instance := range schema.Instances {
		assertions = append(assertions, fmt.Sprintf("// Assertion for instance %s (type: %s)", name, instance.Type))
		assertions = append(assertions, fmt.Sprintf(`require.Contains(t, dataMap, "%s", "Instance %s should exist")`, name, name))
	}

	return assertions
}

// generateFieldAssertion creates an assertion for a single field
func generateFieldAssertion(field SequenceItem, parentVar string) string {
	if field.Contents != nil {
		// For content fields, we don't need to check the actual value since it's validated during parsing
		return fmt.Sprintf(`// Field %s has fixed contents which are validated during parsing`, field.ID)
	}

	if field.Repeat != "" {
		// For repeated fields, check that it's an array
		return fmt.Sprintf(`arr, ok := %s["%s"].([]interface{})
		require.True(t, ok, "Field %s should be an array")
		// TODO: Add specific assertions for array elements`, parentVar, field.ID, field.ID)
	}

	// Handle different primitive types
	switch field.Type {
	case "u1", "u2", "u4", "u8", "u2le", "u4le", "u8le", "u2be", "u4be", "u8be":
		return fmt.Sprintf(`require.Contains(t, %s, "%s", "Field %s should exist")
		// TODO: Add specific assertion for the unsigned integer value`, parentVar, field.ID, field.ID)
	case "s1", "s2", "s4", "s8", "s2le", "s4le", "s8le", "s2be", "s4be", "s8be":
		return fmt.Sprintf(`require.Contains(t, %s, "%s", "Field %s should exist")
		// TODO: Add specific assertion for the signed integer value`, parentVar, field.ID, field.ID)
	case "f4", "f8", "f4le", "f8le", "f4be", "f8be":
		return fmt.Sprintf(`require.Contains(t, %s, "%s", "Field %s should exist")
		// TODO: Add specific assertion for the floating point value`, parentVar, field.ID, field.ID)
	case "str", "strz":
		return fmt.Sprintf(`require.Contains(t, %s, "%s", "Field %s should exist")
		// TODO: Add specific assertion for the string value`, parentVar, field.ID, field.ID)
	case "bytes":
		return fmt.Sprintf(`require.Contains(t, %s, "%s", "Field %s should exist")
		// TODO: Add specific assertion for the bytes value`, parentVar, field.ID, field.ID)
	default:
		// For custom types, check that it exists
		return fmt.Sprintf(`require.Contains(t, %s, "%s", "Field %s should exist")
		// TODO: Add specific assertions for this custom type`, parentVar, field.ID, field.ID)
	}
}

// canCompareDirectly determines if we can directly compare binary data
func canCompareDirectly(schema KaitaiSchema) bool {
	// We can't compare directly if there are instances (calculated fields)
	if len(schema.Instances) > 0 {
		return false
	}

	// We can't compare directly if there are user-defined types with instances
	for _, typeDef := range schema.Types {
		if len(typeDef.Instances) > 0 {
			return false
		}
	}

	// TODO: Add more conditions where direct comparison isn't possible

	return true
}

// getOutputPath determines where to write the test file
func getOutputPath(schemaPath string) string {
	dir := filepath.Dir(schemaPath)
	base := filepath.Base(schemaPath)
	testName := toCamel(strings.TrimSuffix(base, filepath.Ext(base)))
	return filepath.Join(dir, fmt.Sprintf("%s_generated_test.go", strings.ToLower(testName)))
}

func main() {
	rootDir := "test/tests/kaitai"
	err := filepath.Walk(rootDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if !info.IsDir() && strings.HasSuffix(info.Name(), ".ksy") {
			if err := processKsy(path); err != nil {
				fmt.Fprintf(os.Stderr, "Error processing %s: %v\n", path, err)
			}
		}
		return nil
	})
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error walking directory: %v\n", err)
		os.Exit(1)
	}
}

func processKsy(schemaPath string) error {
	ksyBytes, err := os.ReadFile(schemaPath)
	if err != nil {
		return fmt.Errorf("failed to read schema file: %w", err)
	}

	var schema KaitaiSchema
	if err := yaml.Unmarshal(ksyBytes, &schema); err != nil {
		return fmt.Errorf("failed to parse schema: %w", err)
	}

	// Generate test data
	testName := toCamel(schema.Meta.ID)
	packageName := strings.ToLower(testName)
	binPath := guessBinaryPath(schemaPath)

	data := SimpleTestData{
		PackageName:        packageName,
		TestName:           testName,
		SchemaPath:         filepath.Base(schemaPath),
		BinaryPath:         binPath,
		RootIsMap:          true, // Default to map for most schemas
		FieldAssertions:    generateFieldAssertions(schema),
		CanCompareDirectly: canCompareDirectly(schema),
	}
	// If the root type has no sequence and no instances, it's likely a simple value
	if len(schema.Seq) == 0 && len(schema.Instances) == 0 {
		data.RootIsMap = false
		// Adjust assertions for direct value testing
		for i, assertion := range data.FieldAssertions {
			data.FieldAssertions[i] = strings.ReplaceAll(assertion, "dataMap", "parsedData")
		}
		data.FieldAssertions = append(data.FieldAssertions, fmt.Sprintf(`assert.Equal(t, parsedData, %s["%s"], "Parsed data should match")`, "parsedData", schema.Seq[0].ID))
	}

	// Generate the test file from template
	tmpl, err := template.New("test").Parse(testTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	outputPath := getOutputPath(schemaPath)
	outFile, err := os.Create(outputPath)
	if err != nil {
		return fmt.Errorf("failed to create output file: %w", err)
	}
	defer outFile.Close()

	if err := tmpl.Execute(outFile, data); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	fmt.Printf("Generated test file: %s\n", outputPath)
	return nil
}

func toCamel(s string) string {
	parts := strings.FieldsFunc(s, func(r rune) bool {
		return r == '_' || r == '-'
	})
	for i, p := range parts {
		parts[i] = strings.Title(p)
	}
	return strings.Join(parts, "")
}
