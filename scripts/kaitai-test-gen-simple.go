package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"runtime"
	"strings"
	"text/template"
	"unicode"
)

var (
	projectRoot   = flag.String("project_root", "", "Project root directory")
	ksyDir        = flag.String("ksy_dir", "test/formats", "KSY files directory")
	binDir        = flag.String("bin_dir", "test/src", "Binary test files directory")
	kscGoTestDir  = flag.String("ksc_go_test_dir", "test/go", "KSC Go test files directory")
	kscGenDir     = flag.String("ksc_gen_dir", "testdata/formats_kaitai_go_gen", "KSC generated Go files directory")
	testOutputDir = flag.String("test_output_dir", "testdata/kaitaistruct/formats_test", "Test output directory")
)

type TestData struct {
	FormatName   string
	StructName   string
	KsyFileName  string
	BinFileName  string
	PackageAlias string
	Assertions   []Assertion
}

type Assertion struct {
	FieldPath     []string // e.g., ["ltr"] for r.Ltr
	MethodName    string   // e.g., "AsInt", "AsStr"
	Expected      string   // e.g., "12345678"
	AssertionCode string   // Generated assertion code
}

const testTemplate = `// Code generated by generate_kaitai_tests.go; DO NOT EDIT.
package formats_test

import (
	"bytes"
	"context"
	"encoding/json"
	"os"
	"path/filepath"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"testing"

	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kaitai-io/kaitai_struct_go_runtime/kaitai"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/twinfer/kbin-plugin/pkg/kaitaistruct"
	{{.PackageAlias}} "github.com/twinfer/kbin-plugin/testdata/formats_kaitai_go_gen/{{.FormatName}}"
)

func TestParse_{{.StructName}}(t *testing.T) {
	// Load schema
	ksyPath := filepath.Join("../../../test/formats", "{{.KsyFileName}}")
	yamlData, err := os.ReadFile(ksyPath)
	require.NoError(t, err)
	
	schema, err := kaitaistruct.NewKaitaiSchemaFromYAML(yamlData)
	require.NoError(t, err)
	
	interpreter, err := kaitaistruct.NewKaitaiInterpreter(schema, nil)
	require.NoError(t, err)

	// Read binary file
	binPath := filepath.Join("../../../test/src", "{{.BinFileName}}")
	binData, err := os.ReadFile(binPath)
	require.NoError(t, err)

	// Parse with custom parser
	stream := kaitai.NewStream(bytes.NewReader(binData))
	parsed, err := interpreter.Parse(context.Background(), stream)
	require.NoError(t, err)
	
	// Convert to map for assertions
	customMap := kaitaistruct.ParsedDataToMap(parsed).(map[string]any)

	// Assertions from KSC test
	{{range .Assertions}}
	{{.AssertionCode}}
	{{- end}}
}



func TestSerialize_{{.StructName}}(t *testing.T) {
	// Load schema
	ksyPath := filepath.Join("../../../test/formats", "{{.KsyFileName}}")
	yamlData, err := os.ReadFile(ksyPath)
	require.NoError(t, err)
	
	schema, err := kaitaistruct.NewKaitaiSchemaFromYAML(yamlData)
	require.NoError(t, err)
	
	serializer, err := kaitaistruct.NewKaitaiSerializer(schema, nil)
	require.NoError(t, err)

	// Read original binary
	binPath := filepath.Join("../../../test/src", "{{.BinFileName}}")
	originalData, err := os.ReadFile(binPath)
	require.NoError(t, err)

	// Parse original
	stream := kaitai.NewStream(bytes.NewReader(originalData))
	original := {{.PackageAlias}}.New{{.StructName}}()
	err = original.Read(stream, original, original)
	require.NoError(t, err)

	// Serialize and verify round-trip
	inputMap := structToMap{{.StructName}}(t, original)
	
	serialized, err := serializer.Serialize(context.Background(), inputMap)
	require.NoError(t, err)

	// Parse serialized data
	stream2 := kaitai.NewStream(bytes.NewReader(serialized))
	reparsed := {{.PackageAlias}}.New{{.StructName}}()
	err = reparsed.Read(stream2, reparsed, reparsed)
	require.NoError(t, err)

	// Compare structures
	if diff := cmp.Diff(original, reparsed, cmpopts.EquateEmpty()); diff != "" {
		t.Errorf("Serialization mismatch (-original +reparsed):\n%s", diff)
	}
}

// structToMap{{.StructName}} converts KSC struct to map for serializer
func structToMap{{.StructName}}(t *testing.T, data any) map[string]any {
	// Use reflection to handle KSC structs with method-based values
	return structToMapReflective{{.StructName}}(t, data)
}

// structToMapReflective{{.StructName}} uses reflection to convert KSC structs including method calls
func structToMapReflective{{.StructName}}(t *testing.T, data any) map[string]any {
	result := make(map[string]any)
	
	val := reflect.ValueOf(data)
	if val.Kind() == reflect.Ptr {
		val = val.Elem()
	}
	
	typ := val.Type()
	
	// Process fields
	for i := 0; i < val.NumField(); i++ {
		field := typ.Field(i)
		fieldVal := val.Field(i)
		
		// Skip internal KSC fields
		if strings.HasPrefix(field.Name, "_") {
			continue
		}
		
		fieldName := strings.ToLower(field.Name)
		
		if !fieldVal.IsValid() || fieldVal.IsZero() {
			continue
		}
		
		// Handle different field types
		switch fieldVal.Kind() {
		case reflect.Ptr:
			if !fieldVal.IsNil() {
				// For custom types, check for AsInt/AsStr methods
				subResult := make(map[string]any)
				
				// Try to call AsInt method
				if method := fieldVal.MethodByName("AsInt"); method.IsValid() {
					if results := method.Call(nil); len(results) == 2 && results[1].IsNil() {
						subResult["asint"] = results[0].Interface()
					}
				}
				
				// Try to call AsStr method  
				if method := fieldVal.MethodByName("AsStr"); method.IsValid() {
					if results := method.Call(nil); len(results) == 2 && results[1].IsNil() {
						subResult["asstr"] = results[0].Interface()
					}
				}
				
				// Also include raw fields
				subMap := structToMapReflective{{.StructName}}(t, fieldVal.Interface())
				for k, v := range subMap {
					if _, exists := subResult[k]; !exists {
						subResult[k] = v
					}
				}
				
				result[fieldName] = subResult
			}
		case reflect.Slice:
			if fieldVal.Len() > 0 {
				slice := make([]any, fieldVal.Len())
				for j := 0; j < fieldVal.Len(); j++ {
					slice[j] = fieldVal.Index(j).Interface()
				}
				result[fieldName] = slice
			}
		default:
			result[fieldName] = fieldVal.Interface()
		}
	}
	
	return result
}
`

func main() {
	flag.Parse()

	rootDir := getProjectRoot()
	if *projectRoot != "" {
		rootDir = *projectRoot
	}

	// Setup directories
	absKsyDir := filepath.Join(rootDir, *ksyDir)
	absKscGoTestDir := filepath.Join(rootDir, *kscGoTestDir)
	absKscGenDir := filepath.Join(rootDir, *kscGenDir)
	absTestOutputDir := filepath.Join(rootDir, *testOutputDir)

	log.Printf("Processing KSY files from: %s", absKsyDir)

	// Ensure output directories exist
	os.MkdirAll(absKscGenDir, 0755)
	os.MkdirAll(absTestOutputDir, 0755)

	// Process each KSY file
	ksyFiles, _ := filepath.Glob(filepath.Join(absKsyDir, "*.ksy"))

	tmpl := template.Must(template.New("test").Parse(testTemplate))

	for _, ksyFile := range ksyFiles {
		formatName := strings.TrimSuffix(filepath.Base(ksyFile), ".ksy")
		goPackageName := toGoPackageName(formatName)

		log.Printf("Processing: %s", formatName)

		// Generate KSC code
		if err := generateKSC(ksyFile, absKscGenDir, goPackageName, absKsyDir); err != nil {
			log.Printf("  Skipping %s: KSC generation failed: %v", formatName, err)
			continue
		}

		// Extract test data from KSC test file
		kscTestFile := filepath.Join(absKscGoTestDir, goPackageName+"_test.go")
		testData, err := extractTestData(kscTestFile, formatName)
		if err != nil {
			log.Printf("  Skipping %s: %v", formatName, err)
			continue
		}

		// Generate test file
		outputPath := filepath.Join(absTestOutputDir, goPackageName+"_gen_test.go")
		if err := generateTest(tmpl, testData, outputPath); err != nil {
			log.Printf("  Failed to generate test for %s: %v", formatName, err)
			continue
		}

		log.Printf("  âœ“ Generated test for %s", formatName)
	}
}

func getProjectRoot() string {
	_, b, _, ok := runtime.Caller(0)
	if !ok {
		log.Fatal("Failed to get caller information to determine script directory")
	}
	scriptDir := filepath.Dir(b) // Directory of generate_kaitai_tests.go
	// Assume script is in PROJECT_ROOT/scripts/
	// So, project root is one level up from scriptDir
	fmt.Println("Project root determined as:", filepath.Clean(filepath.Join(scriptDir, "..")))
	return filepath.Clean(filepath.Join(scriptDir, ".."))

}

func toGoPackageName(name string) string {
	return strings.ReplaceAll(strings.ReplaceAll(name, "-", "_"), ".", "_")
}

func toPascalCase(s string) string {
	var result strings.Builder
	capitalizeNext := true
	for _, r := range s {
		if r == '_' || r == '-' {
			capitalizeNext = true
			continue
		}
		if capitalizeNext {
			result.WriteRune(unicode.ToUpper(r))
			capitalizeNext = false
		} else {
			result.WriteRune(r)
		}
	}
	return result.String()
}

func generateKSC(ksyFile, outDir, packageName, importPath string) error {
	cmd := exec.Command("ksc", "-t", "go",
		"--outdir", outDir,
		"--go-package", packageName,
		"--import-path", importPath,
		ksyFile)

	var stderr bytes.Buffer
	cmd.Stderr = &stderr

	if err := cmd.Run(); err != nil {
		return fmt.Errorf("ksc failed: %v\nstderr: %s", err, stderr.String())
	}
	return nil
}

func extractTestData(testFile, formatName string) (*TestData, error) {
	content, err := os.ReadFile(testFile)
	if err != nil {
		return nil, fmt.Errorf("cannot read test file: %v", err)
	}

	// Extract binary filename using regex
	binFileRe := regexp.MustCompile(`os\.Open\(".*?([^/]+\.bin)"\)`)
	matches := binFileRe.FindSubmatch(content)
	if len(matches) < 2 {
		return nil, fmt.Errorf("cannot find binary filename in test")
	}
	binFileName := string(matches[1])

	// Parse AST for assertions
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, testFile, nil, 0)
	if err != nil {
		return nil, fmt.Errorf("cannot parse test file: %v", err)
	}

	// Extract assertions
	visitor := &assertionVisitor{
		fset:           fset,
		assertions:     []Assertion{},
		varAssignments: make(map[string]string),
	}
	ast.Walk(visitor, node)

	goPackageName := toGoPackageName(formatName)

	return &TestData{
		FormatName:   formatName,
		StructName:   toPascalCase(goPackageName),
		KsyFileName:  formatName + ".ksy",
		BinFileName:  binFileName,
		PackageAlias: goPackageName + "_kaitai",
		Assertions:   visitor.assertions,
	}, nil
}

type assertionVisitor struct {
	fset           *token.FileSet
	assertions     []Assertion
	varAssignments map[string]string // Maps var names to their expressions
}

func (v *assertionVisitor) Visit(node ast.Node) ast.Visitor {
	// Look for variable assignments like: tmp1, err := r.Ltr.AsInt()
	if assign, ok := node.(*ast.AssignStmt); ok {
		if len(assign.Lhs) >= 1 && len(assign.Rhs) == 1 {
			if ident, ok := assign.Lhs[0].(*ast.Ident); ok {
				// Store the expression for this variable
				v.varAssignments[ident.Name] = v.nodeToString(assign.Rhs[0])
			}
		}
		return v
	}

	// Look for assert.EqualValues calls
	call, ok := node.(*ast.CallExpr)
	if !ok {
		return v
	}

	sel, ok := call.Fun.(*ast.SelectorExpr)
	if !ok {
		return v
	}

	if ident, ok := sel.X.(*ast.Ident); ok && ident.Name == "assert" && sel.Sel.Name == "EqualValues" {
		if len(call.Args) >= 3 {
			expected := v.nodeToString(call.Args[1])
			actualNode := call.Args[2]
			var fieldPath []string
			var methodName string
			var successfullyParsedActual bool

			// Check if actual is a variable reference
			if varIdent, ok := actualNode.(*ast.Ident); ok {
				// Look up what this variable was assigned to
				if expr, found := v.varAssignments[varIdent.Name]; found {
					// Parse the expression to extract field path and method
					fieldPath, methodName = v.parseExpression(expr)
					successfullyParsedActual = true
				}
			} else if callExpr, ok := actualNode.(*ast.CallExpr); ok { // Handle r.Field.Method() directly
				actualExprStr := v.nodeToString(callExpr)
				fieldPath, methodName = v.parseExpression(actualExprStr)
				successfullyParsedActual = true
			} else if selExpr, ok := actualNode.(*ast.SelectorExpr); ok { // Handle r.Field directly
				actualExprStr := v.nodeToString(selExpr)
				fieldPath, methodName = v.parseExpression(actualExprStr)
				successfullyParsedActual = true
			}

			if successfullyParsedActual && len(fieldPath) > 0 {
				assertion := v.generateAssertion(fieldPath, methodName, expected)
				v.assertions = append(v.assertions, assertion)
			}
		}
	}

	return v
}

func (v *assertionVisitor) parseExpression(expr string) ([]string, string) {
	// Parse expressions like "r.Ltr.AsInt()" or "r.FieldName"
	expr = strings.TrimPrefix(expr, "r.")

	isMethodCall := strings.HasSuffix(expr, "()")
	if isMethodCall {
		expr = strings.TrimSuffix(expr, "()")
	}

	parts := strings.Split(expr, ".")
	if len(parts) > 0 {
		if isMethodCall && (parts[len(parts)-1] == "AsInt" || parts[len(parts)-1] == "AsStr") {
			methodName := parts[len(parts)-1]
			fieldPath := parts[:len(parts)-1]
			return fieldPath, methodName
		}
		// If not AsInt/AsStr or not a method call, it's a direct field path
		return parts, ""
	}
	return nil, ""
}

func (v *assertionVisitor) generateAssertion(fieldPath []string, methodName string, expected string) Assertion {
	// Generate assertion code for custom parser map access
	var code strings.Builder

	// Use PascalCase for map keys (ParsedDataToMap uses testutil.ToPascalCase)
	pascalPath := make([]string, len(fieldPath))
	for i, p := range fieldPath {
		pascalPath[i] = toPascalCase(p) // KSY names like "my_field" become "MyField"
	}

	fullAccessPathString := strings.Join(pascalPath, ".")
	if methodName != "" {
		fullAccessPathString += "." + methodName // For display in comments/errors
	}
	code.WriteString(fmt.Sprintf("\t// Assert %s\n", fullAccessPathString))

	currentMapVar := "customMap"
	varPathPrefix := strings.ToLower(strings.Join(pascalPath, "_")) // For unique temp var names

	// Build nested access for map[string]any
	for i, key := range pascalPath {
		tempVar := fmt.Sprintf("%s_lvl%d", varPathPrefix, i) // e.g. ltr_lvl0, header_version_lvl0

		if i < len(pascalPath)-1 {
			// This is an intermediate key in the path, its value must be another map.
			code.WriteString(fmt.Sprintf("\tif %s_map, ok := %s[\"%s\"].(map[string]any); ok {\n", tempVar, currentMapVar, key))
			currentMapVar = tempVar + "_map" // Update current map variable for the next level of nesting
		} else {
			// This is the last key in the path.
			finalValueVar := fmt.Sprintf("%s_val", varPathPrefix) // e.g. ltr_val, header_version_val

			if methodName != "" {
				// Accessing an instance (like AsInt, AsStr) within the map of the last key.
				// The value of 'key' must be a map, and 'methodName' is a key in that map.
				code.WriteString(fmt.Sprintf("\tif %s_instancemap, ok := %s[\"%s\"].(map[string]any); ok {\n", tempVar, currentMapVar, key))
				code.WriteString(fmt.Sprintf("\t\tif %s, ok := %s_instancemap[\"%s\"]; ok {\n", finalValueVar, tempVar, methodName))
				code.WriteString(fmt.Sprintf("\t\t\tassert.EqualValues(t, %s, %s)\n", expected, finalValueVar))
				code.WriteString("\t\t} else {\n")
				code.WriteString(fmt.Sprintf("\t\t\tt.Fatalf(\"Instance '%s' not found in %s (map was %%#v)\", %s_instancemap)\n", methodName, fullAccessPathString, tempVar))
				code.WriteString("\t\t}\n")
				code.WriteString("\t} else {\n")
				code.WriteString(fmt.Sprintf("\t\tt.Fatalf(\"Field '%s' (for instance '%s') not found or not a map in %%s[\\\"%%s\\\"] (got %%T)\", %s[\"%s\"])\n", key, methodName, currentMapVar, key, currentMapVar, key))
				code.WriteString("\t}\n")
			} else {
				// Direct access to the value of the last key.
				code.WriteString(fmt.Sprintf("\tif %s, ok := %s[\"%s\"]; ok {\n", finalValueVar, currentMapVar, key))
				code.WriteString(fmt.Sprintf("\t\tassert.EqualValues(t, %s, %s)\n", expected, finalValueVar))
				code.WriteString("\t} else {\n")
				code.WriteString(fmt.Sprintf("\t\tt.Fatalf(\"Field '%s' not found in %s (keys: %%v)\", maps.Keys(%s))\n", key, currentMapVar, currentMapVar))
				code.WriteString("\t}\n")
			}
		}
	}

	// Close the nested if blocks correctly
	for i := len(pascalPath) - 1; i > 0; i-- { // if len(pascalPath) is 1, this loop doesn't run
		code.WriteString("\t} else {\n")
		code.WriteString(fmt.Sprintf("\t\tt.Fatalf(\"Field '%s' not found or not a map while asserting %s\")\n", pascalPath[i-1], fullAccessPathString))
		code.WriteString("\t}\n")
	}

	return Assertion{
		FieldPath:     fieldPath,
		MethodName:    methodName,
		Expected:      expected,
		AssertionCode: code.String(),
	}
}

// toPascalCase defined in kaitai-test-gen-simple.go needs to be accessible or duplicated if ParsedDataToMap uses a different one.
func toPascalCaseFromSnake(s string) string { // Renamed to avoid conflict if already present
	return toPascalCase(s) // Assuming toPascalCase handles snake_case to PascalCase
}

func (v *assertionVisitor) nodeToString(node ast.Node) string {
	var buf bytes.Buffer
	if err := format.Node(&buf, v.fset, node); err != nil {
		return fmt.Sprintf("<error: %v>", err)
	}
	return buf.String()
}

func generateTest(tmpl *template.Template, data *TestData, outputPath string) error {
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return err
	}

	// Add maps import if not already there, for maps.Keys inFatalf
	if !bytes.Contains(buf.Bytes(), []byte("\"maps\"")) {
		// This is a bit of a hack; ideally, imports are managed more robustly.
		// For now, we rely on goimports to add it if maps.Keys is used.
	}
	// Format with goimports
	cmd := exec.Command("goimports")
	cmd.Stdin = &buf

	var out bytes.Buffer
	cmd.Stdout = &out

	if err := cmd.Run(); err != nil {
		// Write unformatted if goimports fails
		return os.WriteFile(outputPath, buf.Bytes(), 0644)
	}

	return os.WriteFile(outputPath, out.Bytes(), 0644)
}
