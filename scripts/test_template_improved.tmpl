{{/* Code generated by generate_kaitai_tests.go; DO NOT EDIT. */}}
package formats_test

import (
	"bytes"
	"context"
	"encoding/json"
	"os"
	"path/filepath"
	"testing"

	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kaitai-io/kaitai_struct_go_runtime/kaitai"
	"github.com/stretchr/testify/require"
	"github.com/twinfer/kbin-plugin/pkg/kaitaistruct"
	{{.FormatPackageAlias}} "github.com/twinfer/kbin-plugin/testdata/formats_kaitai_go_gen/{{.FormatName}}"
	"github.com/twinfer/kbin-plugin/testutil"
)

// Helper function to safely access nested map values for {{.StructName}}
func getMapValueFor{{.StructName}}(m any, path ...string) (any, bool) {
	current := m
	for _, key := range path {
		switch curr := current.(type) {
		case map[string]any:
			val, ok := curr[key]
			if !ok {
				// Try lowercase version
				val, ok = curr[strings.ToLower(key)]
			}
			if !ok {
				return nil, false
			}
			current = val
		default:
			return nil, false
		}
	}
	return current, true
}

// Helper to convert method results based on method name for {{.StructName}}
func convertMethodResultFor{{.StructName}}(value any, methodName string) (any, error) {
	switch methodName {
	case "AsInt", "Int":
		// Handle BCD or other custom integer conversions
		switch v := value.(type) {
		case float64:
			return int(v), nil
		case int:
			return v, nil
		case string:
			// For BCD, the string might need to be parsed
			if i, err := strconv.Atoi(v); err == nil {
				return i, nil
			}
		}
	case "AsStr", "String":
		return fmt.Sprintf("%v", value), nil
	}
	return value, nil
}

func loadKsySchemaFor{{.StructName}}(t *testing.T, ksyPath string) *kaitaistruct.KaitaiSchema {
	yamlData, err := os.ReadFile(ksyPath)
	require.NoError(t, err, "Failed to read KSY file: %s", ksyPath)
	schema, err := kaitaistruct.NewKaitaiSchemaFromYAML(yamlData)
	require.NoError(t, err, "Failed to parse KSY YAML: %s", ksyPath)
	return schema
}

func structToMapForSerializerFor{{.StructName}}(t *testing.T, data any) map[string]any {
	jsonData, err := json.Marshal(data)
	require.NoError(t, err, "Failed to marshal KSC struct to JSON")
	var resultMap map[string]any
	if err := json.Unmarshal(jsonData, &resultMap); err != nil {
		t.Logf("Warning: Could not unmarshal KSC struct directly to map for serializer")
		return map[string]any{"_value": data}
	}
	converted := testutil.ConvertKeysToLowerRecursive(resultMap)
	if convertedMap, ok := converted.(map[string]any); ok {
		return convertedMap
	}
	return map[string]any{"_value": converted}
}

func TestParse_{{.StructName}}(t *testing.T) {
	ksyPath := filepath.Join("../../../test/formats", "{{.KsyFileName}}")
	ksySchema := loadKsySchemaFor{{.StructName}}(t, ksyPath)
	interpreter, err := kaitaistruct.NewKaitaiInterpreter(ksySchema, nil)
	require.NoError(t, err)

	{{if not .TestCases}}
	t.Logf("No binary test cases for {{.FormatName}}, running {{len .Assertions}} assertions from KSC tests")
	{{end}}

	{{range .TestCases}}
	t.Run("{{$.FormatName}}_{{.Name}}_Parse", func(t *testing.T) {
		// .BinFileRelPath is now assumed to hold the full relative path string from the test file
		// to the .bin file, e.g., "../../../test/src/example.bin".
		// Use this path directly for reading the file.
		// To get just the filename, use {{ base .BinFileRelPath }}.
		// t.Logf("Reading binary file: %s (filename: %s)", "{{.BinFileRelPath}}", "{{base .BinFileRelPath}}")
		binData, err := os.ReadFile("{{.BinFileRelPath}}")
		require.NoError(t, err)

		stream := kaitai.NewStream(bytes.NewReader(binData))
		customParsed, err := interpreter.Parse(context.Background(), stream)
		require.NoError(t, err, "Custom parser failed")

		stream = kaitai.NewStream(bytes.NewReader(binData))
		kscParsed := {{$.FormatPackageAlias}}.New{{$.StructName}}()
		err = kscParsed.Read(stream, kscParsed, kscParsed)
		require.NoError(t, err, "KSC generated parser failed")

		customMap := kaitaistruct.ParsedDataToMap(customParsed)
		kscJSON, err := json.Marshal(kscParsed)
		require.NoError(t, err)
		var kscMap map[string]any
		err = json.Unmarshal(kscJSON, &kscMap)
		require.NoError(t, err)

		filteredCustomMap := testutil.FilterMapKeys(customMap.(map[string]any), kscMap)
		if diff := cmp.Diff(kscMap, filteredCustomMap, testutil.NumericComparer, cmpopts.EquateEmpty()); diff != "" {
			t.Errorf("Parser output mismatch (-want +got):\n%s", diff)
		}

		{{if $.Assertions}}
		// Running {{len $.Assertions}} assertions from KSC tests
		{{range $assertion := $.Assertions}}
		t.Run("Assert_{{$assertion.OriginalKscGoExpr}}", func(t *testing.T) {
			{{if eq $assertion.Operation "LEN"}}
			// Length assertion
			val, ok := getMapValueFor{{$.StructName}}(customMap, {{range $idx, $path := $assertion.BaseObjectPath}}{{if $idx}}, {{end}}"{{$path | toLower}}"{{end}})
			require.True(t, ok, "Failed to get value for {{$assertion.OriginalKscGoExpr}}")
			switch v := val.(type) {
			case []any:
				require.EqualValues(t, {{$assertion.ExpectedValueRaw}}, len(v))
			case []byte:
				require.EqualValues(t, {{$assertion.ExpectedValueRaw}}, len(v))
			default:
				t.Errorf("Expected array/slice for length operation, got %T", v)
			}
			{{else if eq $assertion.Operation "INDEX"}}
			// Index assertion
			val, ok := getMapValueFor{{$.StructName}}(customMap, {{range $idx, $path := $assertion.BaseObjectPath}}{{if $idx}}, {{end}}"{{$path | toLower}}"{{end}})
			require.True(t, ok, "Failed to get value for {{$assertion.OriginalKscGoExpr}}")
			switch v := val.(type) {
			case []any:
				require.EqualValues(t, {{$assertion.ExpectedValueRaw}}, v[{{$assertion.OperationArg}}])
			case []byte:
				require.EqualValues(t, {{$assertion.ExpectedValueRaw}}, v[{{$assertion.OperationArg}}])
			default:
				t.Errorf("Expected array/slice for index operation, got %T", v)
			}
			{{else if eq $assertion.Operation "METHOD"}}
			// Method call assertion ({{$assertion.MethodName}})
			val, ok := getMapValueFor{{$.StructName}}(customMap, {{range $idx, $path := $assertion.BaseObjectPath}}{{if $idx}}, {{end}}"{{$path | toLower}}"{{end}})
			require.True(t, ok, "Failed to get value for {{$assertion.OriginalKscGoExpr}}")
			converted, err := convertMethodResultFor{{$.StructName}}(val, "{{$assertion.MethodName}}")
			require.NoError(t, err)
			require.EqualValues(t, {{$assertion.ExpectedValueRaw}}, converted)
			{{else}}
			// Direct value assertion
			val, ok := getMapValueFor{{$.StructName}}(customMap, {{range $idx, $path := $assertion.BaseObjectPath}}{{if $idx}}, {{end}}"{{$path | toLower}}"{{end}})
			require.True(t, ok, "Failed to get value for {{$assertion.OriginalKscGoExpr}}")
			require.EqualValues(t, {{$assertion.ExpectedValueRaw}}, val)
			{{end}}
		})
		{{end}}
		{{end}}
	})
	{{end}}
}

{{if .TestCases}}
func TestSerialize_{{.StructName}}(t *testing.T) {
	ksyPath := filepath.Join("../../../test/formats", "{{.KsyFileName}}")
	ksySchema := loadKsySchemaFor{{.StructName}}(t, ksyPath)
	serializer, err := kaitaistruct.NewKaitaiSerializer(ksySchema, nil)
	require.NoError(t, err)

	{{range .TestCases}}
	t.Run("{{$.FormatName}}_{{.Name}}_Serialize", func(t *testing.T) {
		// .BinFileRelPath is assumed to hold the full relative path string.
		// Use this path directly for reading the file.
		// To get just the filename, use {{ base .BinFileRelPath }}.
		// t.Logf("Using binary file for serialization: %s (filename: %s)", "{{.BinFileRelPath}}", "{{base .BinFileRelPath}}")
		binData, err := os.ReadFile("{{.BinFileRelPath}}")
		require.NoError(t, err)

		goldenStream := kaitai.NewStream(bytes.NewReader(binData))
		goldenStruct := {{$.FormatPackageAlias}}.New{{$.StructName}}()
		err = goldenStruct.Read(goldenStream, goldenStruct, goldenStruct)
		require.NoError(t, err)

		inputMap := structToMapForSerializerFor{{$.StructName}}(t, goldenStruct)
		serializedBytes, err := serializer.Serialize(context.Background(), inputMap)
		require.NoError(t, err)

		reparsedStream := kaitai.NewStream(bytes.NewReader(serializedBytes))
		reparsedStruct := {{$.FormatPackageAlias}}.New{{$.StructName}}()
		err = reparsedStruct.Read(reparsedStream, reparsedStruct, reparsedStruct)
		require.NoError(t, err)

		if diff := cmp.Diff(goldenStruct, reparsedStruct, cmpopts.EquateEmpty()); diff != "" {
			t.Errorf("Serializer output mismatch (-golden, +reparsed):\n%s", diff)
		}
	})
	{{end}}
}
{{end}}
