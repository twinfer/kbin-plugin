package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"
)

var (
	projectRoot   = flag.String("project_root", "", "Project root directory")
	ksyDir        = flag.String("ksy_dir", "test/formats", "KSY files directory")
	binDir        = flag.String("bin_dir", "test/src", "Binary test files directory")
	testOutputDir = flag.String("test_output_dir", "testdata/kaitaistruct/phase2_test", "Test output directory")
)

type TestData struct {
	FormatName   string
	StructName   string
	KsyFileName  string
	BinFileName  string
	PackageAlias string
}

// Phase 2 test template - includes parser tests and serializer round-trip tests for arrays and user-defined types
const phase2TestTemplate = `// Code generated by kaitai-test-gen-phase2.go; DO NOT EDIT.
// Phase 2: Parser tests and kaitaicel round-trip testing with arrays and user-defined types
package phase2_test

import (
	"bytes"
	"context"
	"log/slog"
	"os"
	"path/filepath"
	"reflect"
	"regexp"
	"strings"
	"testing"

	"github.com/google/go-cmp/cmp"
	"github.com/kaitai-io/kaitai_struct_go_runtime/kaitai"
	"github.com/stretchr/testify/require"
	"github.com/twinfer/kbin-plugin/pkg/kaitaistruct"
	{{.PackageAlias}} "github.com/twinfer/kbin-plugin/testdata/formats_kaitai_go_gen/{{.FormatName}}"
)

func TestKaitaiInterpreter_{{.StructName}}(t *testing.T) {
	// Load schema
	ksyPath := filepath.Join("../../../test/formats", "{{.KsyFileName}}")
	yamlData, err := os.ReadFile(ksyPath)
	require.NoError(t, err)
	
	schema, err := kaitaistruct.NewKaitaiSchemaFromYAML(yamlData)
	require.NoError(t, err)
	
	logger := slog.New(slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{Level: slog.LevelDebug}))
	interpreter, err := kaitaistruct.NewKaitaiInterpreter(schema, logger)
	require.NoError(t, err)

	// Read original binary
	binPath := filepath.Join("../../../test/src", "{{.BinFileName}}")
	originalData, err := os.ReadFile(binPath)
	require.NoError(t, err)

	// Parse with kaitai interpreter
	stream := kaitai.NewStream(bytes.NewReader(originalData))
	parsed, err := interpreter.Parse(context.Background(), stream)
	require.NoError(t, err)

	// Parse same data with KSC for comparison
	stream2 := kaitai.NewStream(bytes.NewReader(originalData))
	kscParsed := {{.PackageAlias}}.New{{.StructName}}()
	err = kscParsed.Read(stream2, kscParsed, kscParsed)
	require.NoError(t, err)

	// Convert kaitai interpreter result to map for comparison
	interpretedMap := kaitaistruct.ParsedDataToMap(parsed).(map[string]any)
	
	// Convert KSC result to map for comparison
	kscMap := structToMapExtended{{.StructName}}(t, kscParsed)

	// Compare the two results (allowing for some differences in representation)
	compareParserResults{{.StructName}}(t, interpretedMap, kscMap)
}

func TestKaitaicelRoundTrip_{{.StructName}}(t *testing.T) {
	// Load schema
	ksyPath := filepath.Join("../../../test/formats", "{{.KsyFileName}}")
	yamlData, err := os.ReadFile(ksyPath)
	require.NoError(t, err)
	
	schema, err := kaitaistruct.NewKaitaiSchemaFromYAML(yamlData)
	require.NoError(t, err)
	
	logger := slog.New(slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{Level: slog.LevelDebug}))
	serializer, err := kaitaistruct.NewKaitaiSerializer(schema, logger)
	require.NoError(t, err)

	// Read original binary
	binPath := filepath.Join("../../../test/src", "{{.BinFileName}}")
	originalData, err := os.ReadFile(binPath)
	require.NoError(t, err)

	// Parse original with KSC
	stream := kaitai.NewStream(bytes.NewReader(originalData))
	original := {{.PackageAlias}}.New{{.StructName}}()
	err = original.Read(stream, original, original)
	require.NoError(t, err)

	// Convert KSC struct to map for serializer (including arrays and nested types)
	inputMap := structToMapExtended{{.StructName}}(t, original)
	
	// Serialize with kaitaicel
	serialized, err := serializer.Serialize(context.Background(), inputMap)
	require.NoError(t, err)

	// Parse serialized data with KSC
	stream2 := kaitai.NewStream(bytes.NewReader(serialized))
	reparsed := {{.PackageAlias}}.New{{.StructName}}()
	err = reparsed.Read(stream2, reparsed, reparsed)
	require.NoError(t, err)

	// Compare structures (including arrays and nested types)
	compareExtendedFields{{.StructName}}(t, original, reparsed)
}

// structToMapExtended{{.StructName}} converts KSC struct to map, handling arrays and user-defined types
func structToMapExtended{{.StructName}}(t *testing.T, data any) map[string]any {
	result := make(map[string]any)
	
	val := reflect.ValueOf(data)
	if val.Kind() == reflect.Ptr {
		val = val.Elem()
	}
	
	typ := val.Type()
	
	// Process fields including arrays and nested types
	for i := 0; i < val.NumField(); i++ {
		field := typ.Field(i)
		fieldVal := val.Field(i)
		
		// Skip internal KSC fields
		if strings.HasPrefix(field.Name, "_") {
			continue
		}
		
		// Convert Go field name back to kaitai field ID
		fieldName := toKaitaiFieldName(field.Name)
		
		if !fieldVal.IsValid() || fieldVal.IsZero() {
			continue
		}
		
		// Handle different field types for Phase 2
		switch fieldVal.Kind() {
		case reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
			result[fieldName] = fieldVal.Interface()
		case reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
			result[fieldName] = fieldVal.Interface()
		case reflect.Float32, reflect.Float64:
			result[fieldName] = fieldVal.Interface()
		case reflect.String:
			result[fieldName] = fieldVal.Interface()
		case reflect.Int:
			// Handle enums - KSC generates enums as custom types with underlying int
			if fieldVal.Type().Name() != "int" {
				result[fieldName] = int(fieldVal.Int())
			} else {
				result[fieldName] = fieldVal.Interface()
			}
		case reflect.Slice:
			if fieldVal.Type().Elem().Kind() == reflect.Uint8 {
				// Handle []byte
				result[fieldName] = fieldVal.Interface()
			} else {
				// Handle slices of structs/other types
				sliceResult := make([]any, fieldVal.Len())
				for j := 0; j < fieldVal.Len(); j++ {
					elem := fieldVal.Index(j)
					if elem.Kind() == reflect.Ptr {
						// Nested struct
						sliceResult[j] = structToMapExtended{{.StructName}}(t, elem.Interface())
					} else {
						// Basic type in array
						sliceResult[j] = elem.Interface()
					}
				}
				result[fieldName] = sliceResult
			}
		case reflect.Ptr:
			// Handle nested user-defined types
			if !fieldVal.IsNil() {
				result[fieldName] = structToMapExtended{{.StructName}}(t, fieldVal.Interface())
			}
		}
	}
	
	return result
}

// compareParserResults{{.StructName}} compares parser outputs allowing for representation differences
func compareParserResults{{.StructName}}(t *testing.T, interpreted, ksc map[string]any) {
	// For Phase 2, we do a deep comparison of the nested structures
	// This is more flexible than exact matching due to potential differences in how
	// the interpreter vs KSC represent nested data
	
	for key, kscVal := range ksc {
		interpretedVal, exists := interpreted[key]
		if !exists {
			t.Errorf("Key %s missing from interpreted result", key)
			continue
		}
		
		// Compare values with type flexibility
		if !deepEqual(kscVal, interpretedVal) {
			t.Errorf("Value mismatch for key %s: ksc=%+v, interpreted=%+v", key, kscVal, interpretedVal)
		}
	}
}

// compareExtendedFields{{.StructName}} compares arrays and nested types in round-trip test
func compareExtendedFields{{.StructName}}(t *testing.T, original, reparsed any) {
	origVal := reflect.ValueOf(original)
	reparsedVal := reflect.ValueOf(reparsed)
	
	if origVal.Kind() == reflect.Ptr {
		origVal = origVal.Elem()
	}
	if reparsedVal.Kind() == reflect.Ptr {
		reparsedVal = reparsedVal.Elem()
	}
	
	typ := origVal.Type()
	
	for i := 0; i < origVal.NumField(); i++ {
		field := typ.Field(i)
		
		// Skip internal fields
		if strings.HasPrefix(field.Name, "_") {
			continue
		}
		
		origFieldVal := origVal.Field(i)
		reparsedFieldVal := reparsedVal.Field(i)
		
		// Compare different types including arrays and nested structs
		switch origFieldVal.Kind() {
		case reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64,
			 reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
			 reflect.Float32, reflect.Float64, reflect.String:
			if origFieldVal.Interface() != reparsedFieldVal.Interface() {
				t.Errorf("Field %s mismatch: original=%v, reparsed=%v", 
					field.Name, origFieldVal.Interface(), reparsedFieldVal.Interface())
			}
		case reflect.Int:
			// Handle enums
			if origFieldVal.Int() != reparsedFieldVal.Int() {
				t.Errorf("Field %s mismatch: original=%v, reparsed=%v", 
					field.Name, origFieldVal.Interface(), reparsedFieldVal.Interface())
			}
		case reflect.Slice:
			// Compare arrays/slices
			if diff := cmp.Diff(origFieldVal.Interface(), reparsedFieldVal.Interface()); diff != "" {
				t.Errorf("Field %s mismatch (-original +reparsed):\n%s", field.Name, diff)
			}
		case reflect.Ptr:
			// Compare nested structs recursively
			if origFieldVal.IsNil() != reparsedFieldVal.IsNil() {
				t.Errorf("Field %s nil mismatch: original=%v, reparsed=%v", 
					field.Name, origFieldVal.IsNil(), reparsedFieldVal.IsNil())
			} else if !origFieldVal.IsNil() {
				// Recursively compare nested structs
				compareExtendedFields{{.StructName}}(t, origFieldVal.Interface(), reparsedFieldVal.Interface())
			}
		}
	}
}

// Helper functions are in helpers.go
`

// Phase 2 formats - arrays and user-defined types without computed instances
var phase2Formats = []string{
	"repeat_n_struct", // Arrays of structs with dynamic count
	"nested_types",    // Nested user-defined types
}

func main() {
	flag.Parse()

	if *projectRoot == "" {
		log.Fatal("project_root flag is required")
	}

	ksyDirPath := filepath.Join(*projectRoot, *ksyDir)
	binDirPath := filepath.Join(*projectRoot, *binDir)
	testOutputDirPath := filepath.Join(*projectRoot, *testOutputDir)

	// Create output directory
	err := os.MkdirAll(testOutputDirPath, 0755)
	if err != nil {
		log.Fatalf("Failed to create test output directory: %v", err)
	}

	tmpl := template.Must(template.New("test").Parse(phase2TestTemplate))

	for _, formatName := range phase2Formats {
		generatePhase2Test(tmpl, formatName, ksyDirPath, binDirPath, testOutputDirPath)
	}
}

func generatePhase2Test(tmpl *template.Template, formatName, ksyDirPath, binDirPath, testOutputDirPath string) {
	ksyFileName := formatName + ".ksy"
	
	// Find corresponding binary file
	binFileName := findBinaryFile(formatName, binDirPath)
	if binFileName == "" {
		log.Printf("Warning: No binary file found for %s", formatName)
		return
	}

	structName := toPascalCase(formatName)
	packageAlias := toSnakeCase(formatName)

	testData := TestData{
		FormatName:   formatName,
		StructName:   structName,
		KsyFileName:  ksyFileName,
		BinFileName:  binFileName,
		PackageAlias: packageAlias,
	}

	var buf bytes.Buffer
	err := tmpl.Execute(&buf, testData)
	if err != nil {
		log.Fatalf("Failed to execute template for %s: %v", formatName, err)
	}

	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		log.Printf("Warning: Failed to format generated code for %s: %v", formatName, err)
		formatted = buf.Bytes()
	}

	// Write test file
	testFileName := formatName + "_test.go"
	testFilePath := filepath.Join(testOutputDirPath, testFileName)
	
	err = os.WriteFile(testFilePath, formatted, 0644)
	if err != nil {
		log.Fatalf("Failed to write test file %s: %v", testFilePath, err)
	}

	fmt.Printf("Generated Phase 2 test: %s\n", testFilePath)
}

func findBinaryFile(formatName, binDirPath string) string {
	// Common binary file patterns
	patterns := []string{
		formatName + ".bin",
		"fixed_struct.bin", // Many tests use this
		"repeat_n_struct.bin",
	}

	for _, pattern := range patterns {
		binPath := filepath.Join(binDirPath, pattern)
		if _, err := os.Stat(binPath); err == nil {
			return pattern
		}
	}

	return ""
}

func toPascalCase(s string) string {
	parts := strings.Split(s, "_")
	for i, part := range parts {
		if len(part) > 0 {
			parts[i] = strings.ToUpper(part[:1]) + part[1:]
		}
	}
	return strings.Join(parts, "")
}

func toSnakeCase(s string) string {
	// Convert camelCase/PascalCase to snake_case for package alias
	re := regexp.MustCompile(`([a-z0-9])([A-Z])`)
	s = re.ReplaceAllString(s, `${1}_${2}`)
	return strings.ToLower(s)
}