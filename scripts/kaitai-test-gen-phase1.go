package main

// import (
// 	"bytes"
// 	"flag"
// 	"fmt"
// 	"go/format"
// 	"log"
// 	"os"
// 	"path/filepath"
// 	"regexp"
// 	"strings"
// 	"text/template"
// )

// var (
// 	projectRoot   = flag.String("project_root", "", "Project root directory")
// 	ksyDir        = flag.String("ksy_dir", "test/formats", "KSY files directory")
// 	binDir        = flag.String("bin_dir", "test/src", "Binary test files directory")
// 	testOutputDir = flag.String("test_output_dir", "testdata/kaitaistruct/phase1_test", "Test output directory")
// )

// type TestData struct {
// 	FormatName   string
// 	StructName   string
// 	KsyFileName  string
// 	BinFileName  string
// 	PackageAlias string
// }

// // Phase 1 test template - focuses on basic serialization without computed instances
// const phase1TestTemplate = `// Code generated by kaitai-test-gen-phase1.go; DO NOT EDIT.
// // Phase 1: Basic kaitaicel round-trip testing without computed instances
// package phase1_test

// import (
// 	"bytes"
// 	"context"
// 	"log/slog"
// 	"os"
// 	"path/filepath"
// 	"reflect"
// 	"regexp"
// 	"strings"
// 	"testing"

// 	"github.com/google/go-cmp/cmp"
// 	"github.com/kaitai-io/kaitai_struct_go_runtime/kaitai"
// 	"github.com/stretchr/testify/require"
// 	"github.com/twinfer/kbin-plugin/pkg/kaitaistruct"
// 	{{.PackageAlias}} "github.com/twinfer/kbin-plugin/testdata/formats_kaitai_go_gen/{{.FormatName}}"
// )

// func TestKaitaicelRoundTrip_{{.StructName}}(t *testing.T) {
// 	// Load schema
// 	ksyPath := filepath.Join("../../../test/formats", "{{.KsyFileName}}")
// 	yamlData, err := os.ReadFile(ksyPath)
// 	require.NoError(t, err)
	
// 	schema, err := kaitaistruct.NewKaitaiSchemaFromYAML(yamlData)
// 	require.NoError(t, err)
	
// 	logger := slog.New(slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{Level: slog.LevelDebug}))
// 	serializer, err := kaitaistruct.NewKaitaiSerializer(schema, logger)
// 	require.NoError(t, err)

// 	// Read original binary
// 	binPath := filepath.Join("../../../test/src", "{{.BinFileName}}")
// 	originalData, err := os.ReadFile(binPath)
// 	require.NoError(t, err)

// 	// Parse original with KSC
// 	stream := kaitai.NewStream(bytes.NewReader(originalData))
// 	original := {{.PackageAlias}}.New{{.StructName}}()
// 	err = original.Read(stream, original, original)
// 	require.NoError(t, err)

// 	// Convert KSC struct to map for serializer (basic fields only)
// 	inputMap := structToMapBasic{{.StructName}}(t, original)
	
// 	// Serialize with kaitaicel
// 	serialized, err := serializer.Serialize(context.Background(), inputMap)
// 	require.NoError(t, err)

// 	// Parse serialized data with KSC
// 	stream2 := kaitai.NewStream(bytes.NewReader(serialized))
// 	reparsed := {{.PackageAlias}}.New{{.StructName}}()
// 	err = reparsed.Read(stream2, reparsed, reparsed)
// 	require.NoError(t, err)

// 	// Compare basic fields only (skip computed instances)
// 	compareBasicFields{{.StructName}}(t, original, reparsed)
// }

// // structToMapBasic{{.StructName}} converts KSC struct to map, focusing only on basic serializable fields
// func structToMapBasic{{.StructName}}(t *testing.T, data any) map[string]any {
// 	result := make(map[string]any)
	
// 	val := reflect.ValueOf(data)
// 	if val.Kind() == reflect.Ptr {
// 		val = val.Elem()
// 	}
	
// 	typ := val.Type()
	
// 	// Process only basic fields, skip computed instances
// 	for i := 0; i < val.NumField(); i++ {
// 		field := typ.Field(i)
// 		fieldVal := val.Field(i)
		
// 		// Skip internal KSC fields and computed instances
// 		if strings.HasPrefix(field.Name, "_") {
// 			continue
// 		}
		
// 		// Convert Go field name back to kaitai field ID
// 		// Go: Pet1 -> kaitai: pet_1
// 		fieldName := toKaitaiFieldName(field.Name)
		
// 		if !fieldVal.IsValid() || fieldVal.IsZero() {
// 			continue
// 		}
		
// 		// Handle only basic serializable types for Phase 1
// 		switch fieldVal.Kind() {
// 		case reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
// 			result[fieldName] = fieldVal.Interface()
// 		case reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
// 			result[fieldName] = fieldVal.Interface()
// 		case reflect.Float32, reflect.Float64:
// 			result[fieldName] = fieldVal.Interface()
// 		case reflect.String:
// 			result[fieldName] = fieldVal.Interface()
// 		case reflect.Slice:
// 			if fieldVal.Type().Elem().Kind() == reflect.Uint8 {
// 				// Handle []byte
// 				result[fieldName] = fieldVal.Interface()
// 			}
// 		case reflect.Int:
// 			// Handle enums - KSC generates enums as custom types with underlying int
// 			// For serialization, we need the underlying integer value
// 			if fieldVal.Type().Name() != "int" {
// 				// This is likely an enum type, convert to int
// 				result[fieldName] = int(fieldVal.Int())
// 			} else {
// 				result[fieldName] = fieldVal.Interface()
// 			}
// 		}
// 	}
	
// 	return result
// }

// // compareBasicFields{{.StructName}} compares only basic serializable fields
// func compareBasicFields{{.StructName}}(t *testing.T, original, reparsed any) {
// 	origVal := reflect.ValueOf(original)
// 	reparsedVal := reflect.ValueOf(reparsed)
	
// 	if origVal.Kind() == reflect.Ptr {
// 		origVal = origVal.Elem()
// 	}
// 	if reparsedVal.Kind() == reflect.Ptr {
// 		reparsedVal = reparsedVal.Elem()
// 	}
	
// 	typ := origVal.Type()
	
// 	for i := 0; i < origVal.NumField(); i++ {
// 		field := typ.Field(i)
		
// 		// Skip internal fields
// 		if strings.HasPrefix(field.Name, "_") {
// 			continue
// 		}
		
// 		origFieldVal := origVal.Field(i)
// 		reparsedFieldVal := reparsedVal.Field(i)
		
// 		// Compare only basic serializable types
// 		switch origFieldVal.Kind() {
// 		case reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64,
// 			 reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
// 			 reflect.Float32, reflect.Float64, reflect.String:
// 			if origFieldVal.Interface() != reparsedFieldVal.Interface() {
// 				t.Errorf("Field %s mismatch: original=%v, reparsed=%v", 
// 					field.Name, origFieldVal.Interface(), reparsedFieldVal.Interface())
// 			}
// 		case reflect.Int:
// 			// Handle enums - compare underlying int values
// 			if origFieldVal.Int() != reparsedFieldVal.Int() {
// 				t.Errorf("Field %s mismatch: original=%v, reparsed=%v", 
// 					field.Name, origFieldVal.Interface(), reparsedFieldVal.Interface())
// 			}
// 		case reflect.Slice:
// 			if origFieldVal.Type().Elem().Kind() == reflect.Uint8 {
// 				// Compare []byte
// 				if diff := cmp.Diff(origFieldVal.Interface(), reparsedFieldVal.Interface()); diff != "" {
// 					t.Errorf("Field %s mismatch (-original +reparsed):\n%s", field.Name, diff)
// 				}
// 			}
// 		}
// 	}
// }
// `

// // Phase 1 formats - simple structures without computed instances
// var phase1Formats = []string{
// 	"hello_world", // Single u1 field
// 	"enum_0",      // Simple enums with u4 fields
// }

// func main() {
// 	flag.Parse()

// 	if *projectRoot == "" {
// 		log.Fatal("project_root flag is required")
// 	}

// 	ksyDirPath := filepath.Join(*projectRoot, *ksyDir)
// 	binDirPath := filepath.Join(*projectRoot, *binDir)
// 	testOutputDirPath := filepath.Join(*projectRoot, *testOutputDir)

// 	// Create output directory
// 	err := os.MkdirAll(testOutputDirPath, 0755)
// 	if err != nil {
// 		log.Fatalf("Failed to create test output directory: %v", err)
// 	}

// 	tmpl := template.Must(template.New("test").Parse(phase1TestTemplate))

// 	for _, formatName := range phase1Formats {
// 		generatePhase1Test(tmpl, formatName, ksyDirPath, binDirPath, testOutputDirPath)
// 	}
// }

// func generatePhase1Test(tmpl *template.Template, formatName, ksyDirPath, binDirPath, testOutputDirPath string) {
// 	ksyFileName := formatName + ".ksy"

// 	// Find corresponding binary file
// 	binFileName := findBinaryFile(formatName, binDirPath)
// 	if binFileName == "" {
// 		log.Printf("Warning: No binary file found for %s", formatName)
// 		return
// 	}

// 	structName := toPascalCase(formatName)
// 	packageAlias := toSnakeCase(formatName)

// 	testData := TestData{
// 		FormatName:   formatName,
// 		StructName:   structName,
// 		KsyFileName:  ksyFileName,
// 		BinFileName:  binFileName,
// 		PackageAlias: packageAlias,
// 	}

// 	var buf bytes.Buffer
// 	err := tmpl.Execute(&buf, testData)
// 	if err != nil {
// 		log.Fatalf("Failed to execute template for %s: %v", formatName, err)
// 	}

// 	// Format the generated code
// 	formatted, err := format.Source(buf.Bytes())
// 	if err != nil {
// 		log.Printf("Warning: Failed to format generated code for %s: %v", formatName, err)
// 		formatted = buf.Bytes()
// 	}

// 	// Write test file
// 	testFileName := formatName + "_test.go"
// 	testFilePath := filepath.Join(testOutputDirPath, testFileName)

// 	err = os.WriteFile(testFilePath, formatted, 0644)
// 	if err != nil {
// 		log.Fatalf("Failed to write test file %s: %v", testFilePath, err)
// 	}

// 	fmt.Printf("Generated Phase 1 test: %s\n", testFilePath)
// }

// func findBinaryFile(formatName, binDirPath string) string {
// 	// Common binary file patterns
// 	patterns := []string{
// 		formatName + ".bin",
// 		"fixed_struct.bin", // Many simple tests use this
// 	}

// 	for _, pattern := range patterns {
// 		binPath := filepath.Join(binDirPath, pattern)
// 		if _, err := os.Stat(binPath); err == nil {
// 			return pattern
// 		}
// 	}

// 	return ""
// }

// func toPascalCase(s string) string {
// 	parts := strings.Split(s, "_")
// 	for i, part := range parts {
// 		if len(part) > 0 {
// 			parts[i] = strings.ToUpper(part[:1]) + part[1:]
// 		}
// 	}
// 	return strings.Join(parts, "")
// }

// func toSnakeCase(s string) string {
// 	// Convert camelCase/PascalCase to snake_case for package alias
// 	re := regexp.MustCompile(`([a-z0-9])([A-Z])`)
// 	s = re.ReplaceAllString(s, `${1}_${2}`)
// 	return strings.ToLower(s)
// }

// func toKaitaiFieldName(goFieldName string) string {
// 	// Convert Go field name (PascalCase) to kaitai field name (snake_case)
// 	// Pet1 -> pet_1, HelloWorld -> hello_world, MyField2 -> my_field_2
	
// 	// First handle letter followed by number: Pet1 -> Pet_1
// 	re1 := regexp.MustCompile(`([a-zA-Z])([0-9])`)
// 	s := re1.ReplaceAllString(goFieldName, `${1}_${2}`)
	
// 	// Then handle lowercase/number followed by uppercase: myField -> my_Field
// 	re2 := regexp.MustCompile(`([a-z0-9])([A-Z])`)
// 	s = re2.ReplaceAllString(s, `${1}_${2}`)
	
// 	return strings.ToLower(s)
// }
